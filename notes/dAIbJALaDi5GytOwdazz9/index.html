<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>Balancing</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Balancing"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://nahombefekadu.github.io/Dendron/notes/dAIbJALaDi5GytOwdazz9/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="1/2/2022"/><meta property="article:modified_time" content="1/3/2022"/><link rel="canonical" href="https://nahombefekadu.github.io/Dendron/notes/dAIbJALaDi5GytOwdazz9/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/Dendron/_next/static/css/18da1489b3d6fe1b.css" as="style"/><link rel="stylesheet" href="/Dendron/_next/static/css/18da1489b3d6fe1b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/Dendron/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/Dendron/_next/static/chunks/webpack-9a433a9d666ac56f.js" defer=""></script><script src="/Dendron/_next/static/chunks/framework-dc33c0b5493501f0.js" defer=""></script><script src="/Dendron/_next/static/chunks/main-aceaf17e4601e1b1.js" defer=""></script><script src="/Dendron/_next/static/chunks/pages/_app-8a77f75e46e06ef6.js" defer=""></script><script src="/Dendron/_next/static/chunks/155-0a8d44b6408c244d.js" defer=""></script><script src="/Dendron/_next/static/chunks/pages/notes/%5Bid%5D-9cb21e268704eba6.js" defer=""></script><script src="/Dendron/_next/static/R_mEAKXFYPOFoHuo84PR_/_buildManifest.js" defer=""></script><script src="/Dendron/_next/static/R_mEAKXFYPOFoHuo84PR_/_ssgManifest.js" defer=""></script><script src="/Dendron/_next/static/R_mEAKXFYPOFoHuo84PR_/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout site-layout" style="margin-top:64px"><section class="ant-layout site-layout" style="flex-direction:row"><section class="ant-layout site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></section><section class="ant-layout side-layout-main" style="max-width:1200px;display:initial"><main class="ant-layout-content main-content" role="main" style="padding:0 24px"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="balancing"><a aria-hidden="true" class="anchor-heading" href="#balancing"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Balancing</h1>
<p>We know that a BST needs to be well balanced to give optimal performance and results, but there are different ways of balancing trees. Here</p>
<p>One way of balancing BSTs is a tree rotation, tree rotation changes the structure of the tree but does not affect the structure of the tree. Rotations are usually used to balance two branches of different depths.</p>
<p>In a rotation a node is shifted up while another node is shifted down. Other nodes may need to also be shifted to maintain the integrity of the binary tree. These rotations can change the height of the tree by moving large subtrees. As it can be seen below in both rotations the order of the nodes has not changed but the levels of the nodes has shifted.</p>
<p>We can also see that due to the rotation that the children of the nodes being rotated are also shifted but still stay the children of the nodes. Only thing changing the level/depth of these nodes. Thus we can see that this is a great way to balance trees as it does not matter if the node in rotation has parents. Hence we can use rotations at any level/depth within the tree.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-41-37.png" style="max-width:300px;"></p>
<p>In the example below you can see that we can use rotations to make a tree that is unbalanced balanced by applying rotations.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-41-52.png"></p>
<p>For the tree above after rotation has been applied the tree has been balanced. But balancing trees continually is not optimal hence <strong>AVL</strong> is applied.</p>
<hr>
<h2 id="avl"><a aria-hidden="true" class="anchor-heading" href="#avl"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>AVL</h2>
<p>AVL tree are a self balancing BST tree that applies rotation automatically as it's always balanced. Thus it is a much faster operation than most BSTs. When inserting a node the branch is inspected for balancing and the appropriate rotation is applied to make the tree balanced.</p>
<p>AVL looks at pattern of the branches in a tree where insertion of a node is occurring and looks for four patterns.</p>
<ul>
<li>Left-Left</li>
<li>Left-Right</li>
<li>Right-Left</li>
<li>Right-Right</li>
</ul>
<p>It performs these rotations after insertion of a new node, applying rotation to the node one or two levels above it or both.</p>
<p>Left-Left(LL): In this operation a right rotation is performed on the node above the inserted node. As shown in the picture below the inserted node is moved up and the node two levels up is moved down.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-43-22.png"></p>
<p>Left-Right(LR): This is a multi step process where a left rotation on the node above the inserted node is applied moving the above node down and the inserted node up. After which a right rotation is applied on the node that was two levels above the inserted node, moving the inserted node up and the top node down.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-44-15.png"></p>
<p>Right-Left(RL): In this operation a right rotation is performed on the node above the inserted node moving the inserted node up and the above node down. After that a left rotation is performed on the node two that was above two levels the inserted node. moving the above node below the inserted node.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-44-38.png"></p>
<p>Right-Right(RR): In this operation a left rotation is performed on the node above the inserted node, moving it up and the node two levels up down.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-44-52.png"></p>
<p>As can be seen thus far balancing is really easy with AVL trees, But the downsides of AVL is insertion and deletions. In these cases they can be operationally heavy as several rotations per each operation can be required.</p>
<hr>
<h2 id="red-black"><a aria-hidden="true" class="anchor-heading" href="#red-black"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>RED-Black</h2>
<p>There is another self balancing tree similar to AVL, the <strong>red-black tree</strong>. This algorithm does not have strict balancing requirements like AVL so its look up is slower than AVL, but its insertion and deletion operation are much faster due to requiring less rotations per operation.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-46-48.png"></p>
<p>How these trees work is that each node in the tree is either red or black, where new inserted nodes are always marked red. After insertion the color of the surrounding nodes is assessed and the nodes are rotated or repainted to achieve the conditions below:</p>
<ul>
<li>All red leaves must have only child nodes colored black.</li>
<li>the root of the tree must always be black</li>
<li>No matter where you are in the tree, every path to a leave/leaf node must go through the same number of black nodes.</li>
</ul>
<p>The tree resulting from this algorithm is not perfectly balanced as AVL trees but its runtime operation for lookup is still O(log n) and for insertion and deletion.</p>
<p>This is due to the tree having a maximum total height of 2 log (n+1)</p>
<h4 id="insertion"><a aria-hidden="true" class="anchor-heading" href="#insertion"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Insertion</h4>
<p>When a new node is inserted into a red-black tree, the algorithm searches through the tree to find the correct spot based on the value and places the node(similar to BST) then paints the node red. After that is complete it assesses the surrounding nodes and performs either of these 4 actions:</p>
<ol>
<li>
<p>In the first case the new nodes parent is black, the red-black properties are upheld and nothing is done.</p>
</li>
<li>
<p>The second case the new nodes parent and its siblings are painted red. Here you would switch the color of the parent and parent sibling node to black and switch the grandparent to the node to red.</p>
</li>
<li>
<p>Here the new nodes parent is red and its sibling is black, and the new nodes value is between the parent and grandparent.</p>
<ul>
<li>If the new node is greater than the parent, the parent is rotated left, where as if the node is less than the parent the parent is rotated right.</li>
</ul>
</li>
<li>
<p>The last case is where the new nodes parent is red and the parent sibling is black. The parent node should be between the value of the new node and the grandparent.</p>
<ul>
<li>If the new node value is less than the parent, the grandparent is rotated right and the colors of the parent and grandparent are swapped.</li>
<li>if the new node value is greater than the parent, the grandparent is rotated left and the colors are swapped.</li>
</ul>
</li>
</ol>
<p>For the tree below if we were to insert 7, based on rules of BST it will be inserted in the right branch of 6. After which we would follow the cases outlined above, The grandparent (1) is rotated left and the colors of grandparent and parent nodes and it's children are switched.</p>
<p><img src="/Dendron/assets/images/2022-01-02-23-47-14.png"></p>
<p>Another example:
<img src="/Dendron/assets/images/2022-01-02-23-47-35.png"></p>
<hr>
<p>In general AVL and red-black trees will have a faster runtime for lookup compared to BST and binary tree.</p>
<p>Thus we can say that if a runtime of a algorithm for lookup is closer to O(N) we know that it will not be AVL or red-black trees as their lookup time is guaranteed to be in O(log n).</p>
<p>When looking at creating a tree and if we're choosing between AVL and red-black, we look and see if we will be doing lots of insertion and deletion operations if so the best bet is to go with red-black trees. But if the tree is static or unchanging the best tree to use would be AVL.</p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#avl" title="AVL">AVL</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#red-black" title="RED Black">RED Black</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#insertion" title="Insertion">Insertion</a></div></div></div></div></div></div></div></div></div></main><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></section></section></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"dAIbJALaDi5GytOwdazz9","title":"Balancing","desc":"","updated":1641230605722,"created":1641108315833,"custom":{},"fname":"data-structures.binary-trees.balancing","type":"note","vault":{"fsPath":"vault"},"contentHash":"9c00f3a981862039ac63c2e3414bb8b1","links":[],"anchors":{"avl":{"type":"header","text":"AVL","value":"avl","line":26,"column":0,"depth":2},"red-black":{"type":"header","text":"RED-Black","value":"red-black","line":59,"column":0,"depth":2},"insertion":{"type":"header","text":"Insertion","value":"insertion","line":75,"column":0,"depth":4}},"children":[],"parent":"WfdADQRT7cfzOlj1XR8Uz","data":{}},"body":"\u003ch1 id=\"balancing\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#balancing\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eBalancing\u003c/h1\u003e\n\u003cp\u003eWe know that a BST needs to be well balanced to give optimal performance and results, but there are different ways of balancing trees. Here\u003c/p\u003e\n\u003cp\u003eOne way of balancing BSTs is a tree rotation, tree rotation changes the structure of the tree but does not affect the structure of the tree. Rotations are usually used to balance two branches of different depths.\u003c/p\u003e\n\u003cp\u003eIn a rotation a node is shifted up while another node is shifted down. Other nodes may need to also be shifted to maintain the integrity of the binary tree. These rotations can change the height of the tree by moving large subtrees. As it can be seen below in both rotations the order of the nodes has not changed but the levels of the nodes has shifted.\u003c/p\u003e\n\u003cp\u003eWe can also see that due to the rotation that the children of the nodes being rotated are also shifted but still stay the children of the nodes. Only thing changing the level/depth of these nodes. Thus we can see that this is a great way to balance trees as it does not matter if the node in rotation has parents. Hence we can use rotations at any level/depth within the tree.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-41-37.png\" style=\"max-width:300px;\"\u003e\u003c/p\u003e\n\u003cp\u003eIn the example below you can see that we can use rotations to make a tree that is unbalanced balanced by applying rotations.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-41-52.png\"\u003e\u003c/p\u003e\n\u003cp\u003eFor the tree above after rotation has been applied the tree has been balanced. But balancing trees continually is not optimal hence \u003cstrong\u003eAVL\u003c/strong\u003e is applied.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"avl\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#avl\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eAVL\u003c/h2\u003e\n\u003cp\u003eAVL tree are a self balancing BST tree that applies rotation automatically as it's always balanced. Thus it is a much faster operation than most BSTs. When inserting a node the branch is inspected for balancing and the appropriate rotation is applied to make the tree balanced.\u003c/p\u003e\n\u003cp\u003eAVL looks at pattern of the branches in a tree where insertion of a node is occurring and looks for four patterns.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLeft-Left\u003c/li\u003e\n\u003cli\u003eLeft-Right\u003c/li\u003e\n\u003cli\u003eRight-Left\u003c/li\u003e\n\u003cli\u003eRight-Right\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt performs these rotations after insertion of a new node, applying rotation to the node one or two levels above it or both.\u003c/p\u003e\n\u003cp\u003eLeft-Left(LL): In this operation a right rotation is performed on the node above the inserted node. As shown in the picture below the inserted node is moved up and the node two levels up is moved down.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-43-22.png\"\u003e\u003c/p\u003e\n\u003cp\u003eLeft-Right(LR): This is a multi step process where a left rotation on the node above the inserted node is applied moving the above node down and the inserted node up. After which a right rotation is applied on the node that was two levels above the inserted node, moving the inserted node up and the top node down.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-44-15.png\"\u003e\u003c/p\u003e\n\u003cp\u003eRight-Left(RL): In this operation a right rotation is performed on the node above the inserted node moving the inserted node up and the above node down. After that a left rotation is performed on the node two that was above two levels the inserted node. moving the above node below the inserted node.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-44-38.png\"\u003e\u003c/p\u003e\n\u003cp\u003eRight-Right(RR): In this operation a left rotation is performed on the node above the inserted node, moving it up and the node two levels up down.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-44-52.png\"\u003e\u003c/p\u003e\n\u003cp\u003eAs can be seen thus far balancing is really easy with AVL trees, But the downsides of AVL is insertion and deletions. In these cases they can be operationally heavy as several rotations per each operation can be required.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"red-black\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#red-black\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eRED-Black\u003c/h2\u003e\n\u003cp\u003eThere is another self balancing tree similar to AVL, the \u003cstrong\u003ered-black tree\u003c/strong\u003e. This algorithm does not have strict balancing requirements like AVL so its look up is slower than AVL, but its insertion and deletion operation are much faster due to requiring less rotations per operation.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-46-48.png\"\u003e\u003c/p\u003e\n\u003cp\u003eHow these trees work is that each node in the tree is either red or black, where new inserted nodes are always marked red. After insertion the color of the surrounding nodes is assessed and the nodes are rotated or repainted to achieve the conditions below:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAll red leaves must have only child nodes colored black.\u003c/li\u003e\n\u003cli\u003ethe root of the tree must always be black\u003c/li\u003e\n\u003cli\u003eNo matter where you are in the tree, every path to a leave/leaf node must go through the same number of black nodes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe tree resulting from this algorithm is not perfectly balanced as AVL trees but its runtime operation for lookup is still O(log n) and for insertion and deletion.\u003c/p\u003e\n\u003cp\u003eThis is due to the tree having a maximum total height of 2 log (n+1)\u003c/p\u003e\n\u003ch4 id=\"insertion\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#insertion\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eInsertion\u003c/h4\u003e\n\u003cp\u003eWhen a new node is inserted into a red-black tree, the algorithm searches through the tree to find the correct spot based on the value and places the node(similar to BST) then paints the node red. After that is complete it assesses the surrounding nodes and performs either of these 4 actions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eIn the first case the new nodes parent is black, the red-black properties are upheld and nothing is done.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe second case the new nodes parent and its siblings are painted red. Here you would switch the color of the parent and parent sibling node to black and switch the grandparent to the node to red.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHere the new nodes parent is red and its sibling is black, and the new nodes value is between the parent and grandparent.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the new node is greater than the parent, the parent is rotated left, where as if the node is less than the parent the parent is rotated right.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe last case is where the new nodes parent is red and the parent sibling is black. The parent node should be between the value of the new node and the grandparent.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the new node value is less than the parent, the grandparent is rotated right and the colors of the parent and grandparent are swapped.\u003c/li\u003e\n\u003cli\u003eif the new node value is greater than the parent, the grandparent is rotated left and the colors are swapped.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor the tree below if we were to insert 7, based on rules of BST it will be inserted in the right branch of 6. After which we would follow the cases outlined above, The grandparent (1) is rotated left and the colors of grandparent and parent nodes and it's children are switched.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-47-14.png\"\u003e\u003c/p\u003e\n\u003cp\u003eAnother example:\n\u003cimg src=\"/Dendron/assets/images/2022-01-02-23-47-35.png\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eIn general AVL and red-black trees will have a faster runtime for lookup compared to BST and binary tree.\u003c/p\u003e\n\u003cp\u003eThus we can say that if a runtime of a algorithm for lookup is closer to O(N) we know that it will not be AVL or red-black trees as their lookup time is guaranteed to be in O(log n).\u003c/p\u003e\n\u003cp\u003eWhen looking at creating a tree and if we're choosing between AVL and red-black, we look and see if we will be doing lots of insertion and deletion operations if so the best bet is to go with red-black trees. But if the tree is static or unchanging the best tree to use would be AVL.\u003c/p\u003e","noteIndex":{"id":"vVFnvX3AZLb21JIc7L4gm","title":"Root","desc":"","updated":1641184503497,"created":1640015760017,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"dbe76e060067b9059e208c353b2be0be","links":[],"anchors":{"computer-science-library":{"type":"header","text":"Computer Science Library","value":"computer-science-library","line":8,"column":0,"depth":1}},"children":["Yvra9LpGoPLi4Kk2KKGsK","jL0XOOMd1sy4tgf2SWfg5","rydiHYJbn3JhvGgWrK9Sl","l8rNoqR6OrTiJzqzAsfms","Zd60tpALGBOrNJC2avO70","aVtnDm5TBmQfxOgRoc0m1","gh9HX9yN4MF2djOLFCV3N","BeyqjmB3iu9oewp7hCpqg","PbPnrOhcARThoz7ymnam8"],"parent":null,"data":{},"body":"\n# Computer Science Library\n\nThis is a collection of notes ranging from data structures and problems to specific knowledge of a programming language. It is a stored knowledge of different programming languages and applications for easy retrieval and note keeping.\n\nThis repository will be continually updated and maintained as knowledge base grows and aspects of languages are updated.\n\n![](/assets/images/2022-01-02-23-34-36.png)\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":4,"useFMTitle":true,"useNoteTitleForLink":true,"mermaid":true,"useKatex":true,"dev":{"enablePreviewV2":true},"site":{"assetsPrefix":"/Dendron","siteUrl":"https://nahombefekadu.github.io","copyAssets":true,"siteHierarchies":["root"],"siteRootDir":"docs","usePrettyRefs":true,"title":"Dendron","description":"Personal knowledge space","siteLastModified":true,"gh_edit_branch":"main","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"usePrettyLinks":true,"siteNotesDir":"notes","siteFaviconPath":"favicon.ico","gh_edit_link":true,"gh_edit_link_text":"Edit this page on GitHub","gh_root":"docs/","gh_edit_view_mode":"edit","writeStubs":true,"siteIndex":"root"},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{}},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"dAIbJALaDi5GytOwdazz9"},"buildId":"R_mEAKXFYPOFoHuo84PR_","assetPrefix":"/Dendron","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>