[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://nahombefekadu.github.io/Notes/notes\\403.html","relUrl":"notes\\403.html"},{"doc":"Root","title":"Root","hpath":"root","content":"\n# Computer Science Library\n\nThis is a collection of notes ranging from data structures and problems to specific knowledge of a programming language. It is a stored knowledge of different programming languages and applications for easy retrieval and note keeping.\n\nThis repository will be continually updated and maintained as knowledge base grows and aspects of languages are updated.\n\n![Tree of Knowledge](https://static.wikia.nocookie.net/gods_and_demons/images/3/37/Tree_of_the_Knowledge_of_Good_and_Evil.jpg/revision/latest/scale-to-width-down/1000?cb=20200827152526)\n\n## Lookup information\n","url":"https://nahombefekadu.github.io/Notes","relUrl":"/"},{"doc":"Data Structures","title":"Data Structures","hpath":"Data Structures","content":"","url":"https://nahombefekadu.github.io/Notes/notes\\rydiHYJbn3JhvGgWrK9Sl.html","relUrl":"notes\\rydiHYJbn3JhvGgWrK9Sl.html"},{"doc":"Stacks","title":"Stacks","hpath":"Data Structures.Stacks","content":"","url":"https://nahombefekadu.github.io/Notes/notes\\WZ2a0ixYCPWAPCh5x1Alr.html","relUrl":"notes\\WZ2a0ixYCPWAPCh5x1Alr.html"},{"doc":"Sorting","title":"Sorting","hpath":"Data Structures.Sorting","content":"\n","url":"https://nahombefekadu.github.io/Notes/notes\\uW7p8NjutTqHnR7XSlbim.html","relUrl":"notes\\uW7p8NjutTqHnR7XSlbim.html"},{"doc":"Recursion","title":"Recursion","hpath":"Data Structures.Recursion","content":"\n","url":"https://nahombefekadu.github.io/Notes/notes\\kI5aQqoWn5mBeryTGwZZT.html","relUrl":"notes\\kI5aQqoWn5mBeryTGwZZT.html"},{"doc":"Linked List","title":"Linked List","hpath":"Data Structures.Linked List","content":"\n","url":"https://nahombefekadu.github.io/Notes/notes\\DB42sUOqAsy9iqBj9nRsU.html","relUrl":"notes\\DB42sUOqAsy9iqBj9nRsU.html"},{"doc":"Heaps","title":"Heaps","hpath":"Data Structures.Heaps","content":"\n","url":"https://nahombefekadu.github.io/Notes/notes\\8CXVnvHnFeryOMbVH4VGR.html","relUrl":"notes\\8CXVnvHnFeryOMbVH4VGR.html"},{"doc":"Hash Table","title":"Hash Table","hpath":"Data Structures.Hash Table","content":"\n","url":"https://nahombefekadu.github.io/Notes/notes\\OsBqQaabsBn1IoNCCuBRI.html","relUrl":"notes\\OsBqQaabsBn1IoNCCuBRI.html"},{"doc":"Graphs","title":"Graphs","hpath":"Data Structures.Graphs","content":"\n<img src='https://g.gravizo.com/svg?\n digraph G {\n   w -> n;\n   w -> n;\n   w -> s;\n   w -> s;\n   w -> e;\n   e -> n;\n   e -> s;\n }\n'/>\n\nA structure like this is called a graph, and the points W,E,S,N would be called vertices and the lines connecting them can be represented as edges.\n\nA lot of things can be implemented as a graph such as a road network where intersections can be vertices and the road as edges. Graphs are how most GPS devices work.\n\nIf you travel through all the edges once, you'd call the eulerian path, eulerian path is one that uses every edge exactly once and the number of vertices passed does not matter. The eulerian path starts or ends at the vertex, one of the ways to recognize the start and end of a path is by looking at vertices which has an odd number of edges. That means it is one of the two ends of the eulerian path. Thus by that logic we can say that if a graph has more than two vertices with odd edges, there is no eulerian path.\n\nAnother image example of graphs can be found below.\n\n![Graph image](https://miro.medium.com/max/2000/1*HpYMnHjGZWmH9NKRG05lAg.jpeg)\n\nGraphs can also be created to solve and represent puzzle games\nSuch as the farmers problem where the farmer has to get a wolf a goat and cabbage across the river, but the boat they have has only room for one more item.\n\n![Graph image](https://mark-borg.github.io/img/posts/farmer-wolf-goat-cabbage.png)\n\nThis can be represented by a graph as such where each possible state is mapped out including the ones that break the rules of the game. Where the moves made are edges and the arrangement of the items and farmer are vertices.\n\nAs there is 4 characters and three locations we can say that there are 3^4 possible states including invalid moves for the problem:\n![Graph image](http://4.bp.blogspot.com/-HzVCfEjokqg/UVqLVGFtsWI/AAAAAAAAAK8/pxdT7T7xCPQ/s1600/Drawing2.png)\n","url":"https://nahombefekadu.github.io/Notes/notes\\0KnFMcqYC3OeDpEnawCaX.html","relUrl":"notes\\0KnFMcqYC3OeDpEnawCaX.html"},{"doc":"Complexity","title":"Complexity","hpath":"Data Structures.Complexity","content":"\n","url":"https://nahombefekadu.github.io/Notes/notes\\Fpime3qnoVpO5YtLicbYM.html","relUrl":"notes\\Fpime3qnoVpO5YtLicbYM.html"},{"doc":"Binary Trees","title":"Binary Trees","hpath":"Data Structures.Binary Trees","content":"\n![Binary Tree image](https://kevinvecmanis.io/assets/binary_trees/tree2.png)\n\nBinary Tree is a tree data structure in which each node has at most two children,left child and right child. Usually nodes in a tree can have multiple children but binary trees can have only two max. They are a useful data structure for storing data such as numbers and allow for fast lookup using binary search functionality.\n\nthe number of children each node has in a tree is called branching factor, and as such a binary tree has a branching factor of 2.\n\nSimilar to linked list a binary tree has a node which contains a value and a pointer to another node. But in a binary tree it has two pointers one for the left child and one for the right child.\n\n```javascript\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n```\n\n![Binary Tree image](https://miro.medium.com/max/1200/1*tUBYCHi32Zj0B2UCw0qmlA.png)\n\nA binary tree uis made up of nodes and links/edges, The nodes represent the data stored in the tree, and the node at the top is called the root while every other node is a child node or a parent node. The nodes which point to no other node are called Leaf nodes. Nodes which have the same parent are called sibling nodes.\n\nIn general the number of nodes present in a tree will be one more than the number of edges/links present. Thus you can find the number of nodes present by counting the number of edges and adding one.\n\nBelow you can find how simple it is to search though a binary tree.\n\n![Binary Tree image](https://blog.penjee.com/wp-content/uploads/2015/11/binary-search-tree-sorted-array-animation.gif)\n\n---\n\nAnother thing to pay attention for binary trees is the depth, node height, and tree height. To maximize efficiency of searching for an element in the tree.\n\nWe say that the **depth** of a node is the number of links from the root to the node. Thus the root node has a depth of zero and its direct children have a depth of 1.\n\nWe say that the **height** of a tree is the depth of the deepest node present in the tree from the root node. When we want to find a specific **node height** we look at the number of edges present from that node to a leaf node.\n\nTo find the maximum/larges number of nodes a binary tree can have we use this formula: 2^(height or n) - 1 max nodes possible at each tree height.\n\n![Binary Tree image](https://iq.opengenus.org/content/images/2019/07/heightofbinarytree-1.png)\n\nA given binary tree can be a full or complete binary tree. When we say a full binary tree we mean that each node has either exactly zero or two children. Since every node has to point to at least two nodes after the root node, a full binary tree cannot have an even number of nodes.\n\nWhereas a complete binary tree is completely filled(except the last level sometimes) and is made so that all given sub nodes are as far left as possible.\n\n![Binary Tree image](https://www.andrew.cmu.edu/course/15-121/lectures/Trees/pix/full_complete.bmp)\n","url":"https://nahombefekadu.github.io/Notes/notes\\WfdADQRT7cfzOlj1XR8Uz.html","relUrl":"notes\\WfdADQRT7cfzOlj1XR8Uz.html"},{"doc":"Traverse","title":"Traverse","hpath":"Data Structures.Binary Trees.Traverse","content":"\nWhen you navigate through a tree and find all the data it contains you call that a traversal, as it traverses the whole binary tree.\n\n![Binary Tree image](https://i.stack.imgur.com/FFWk3.png)\n\nThe first method of traversal is called is pre-order traversal\n\nFor this you can use a simple recursion algorithm to traverse the tree and print all the letters contained by the nodes.\n\n```javascript\nfunction BSTpre(tree) {\n  if (tree) {\n    print(tree.value);\n    BSTpre(tree.left);\n    BSTpre(tree.right);\n  }\n}\n```\n\nThe second method is called in-order traversal where you go around the tree counterclockwise. In this case the letter is only printed after it has traversed down the left branch. Using this method in a sorted binary tree, you are able to print all numbers in the correct order.\n\n```javascript\nfunction BSTinOrder(tree) {\n  if (tree) {\n    BSTinOrder(tree.left);\n    print(tree.value);\n    BSTinOrder(tree.right);\n  }\n}\n```\n\nThe last method is called post-order traversal similar to in-order traversal you go through the tree counterclockwise but you print the value of each node as you pass the right side instead of the left like in-order. Each value is printed the last time it is reached recursively as it moves left and then right to print the data last.\n\n```javascript\nfunction BSTpost(tree) {\n  if (tree) {\n    BSTpost(tree.left);\n    BSTpost(tree.right);\n    print(tree.value);\n  }\n}\n```\n\nThe method you use to traverse the tree depends on what you are trying to do.\n\n## Depth First Search\n\n![Binary Tree image](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Depth-first-tree.svg/1200px-Depth-first-tree.svg.png)\nDFS is an algorithm where you go down a branch until the leaf is reached and process and proceed to another branch and so on. DFS usually make use of a stack to track all the visited nodes. For depth first search we can utilize any of the methods we outlined above.\n\nSo for the given binary tree below for our DFS if we utilized a pre-order traversal we would come up with the result shown below:\n\npre-order : [1,2,3,4,5,6,7,8,9,10,11,12]\n\n## Breadth First Search\n\n![Binary Tree image](https://upload.wikimedia.org/wikipedia/commons/thumb/3/33/Breadth-first-tree.svg/1200px-Breadth-first-tree.svg.png)\n\nBFS is an algorithm that is counterpart to DFS, where DFS make use of a stack BFS makes use of a queue for its data array. Thus elements are visited in a first in first out method(FIFO). This can also be called level order traversal as all nodes on a given level are visited before going to the next level.\n\nBFS is usually used in maps for finding the shortest route (google maps) or finding how many friend links/ relations you are from someone (facebook or linkedin). BFS is used often when you are looking for the \"nearest\" solution.\n\nSo in total the traversal algorithm are as follows:\n\n- BFS\n- pre-order traversal\n- in-order traversal\n- post-order traversal\n","url":"https://nahombefekadu.github.io/Notes/notes\\v4OODim5jeNuuURCTzWU5.html","relUrl":"notes\\v4OODim5jeNuuURCTzWU5.html"},{"doc":"Search Trees","title":"Search Trees","hpath":"Data Structures.Binary Trees.Search Trees","content":"\nBinary trees are used to store data so we want to have them be structured and sorted so that they are easy to search as previously stated. This is where Binary Search Trees(BST) come in, BST is a Binary tree where each node on the left(left subtree) has to contain smaller values and all nodes on the right(subtree) have to contain large values.\n\nBSTs do not have any duplicate elements in the tree.\n\n![Binary Tree image](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/640px-Binary_search_tree.svg.png)\n\nFollowing the given image above and using the rules stated above we can state that for example to insert 9 into the tree we can only do so as the left child of 10. 9 is greater than 8 so would have to go right side, we can't put it as a child of 13 as its a child of 14 which is greater than 10 thus all children of 14 have to be greater than 10.\n\nSo as an example for our BST above if we chose to implement the 4 traversal methods previously mentioned we would have the results shown below:\n\n- BFS : [8,3,10,1,6,14,4,7,13]\n- pre-order traversal : [8,3,1,6,4,7,10,14,13]\n- in-order traversal: [1,3,4,6,7,8,10,13,14]\n- post-order traversal : [1,4,7,6,3,13,14,10,8]\n\n---\n\nWhen working with BST if we want the best performance BST should be well balanced, so that both Branches are filled with no gaps. leaving a complete branch as previously stated.\n\nWe know that for any given BST that is complete/balanced, the time taken to find a given node is proportional to the node depth equal to approximately log2(n). therefore the runtime of this search will be of O(log n).\n\nFor an unbalanced tree the performance of the search is not as optimal as a balanced tree thus its runtime will be of O(n). Thus we can say that for a given tree its runtime will be between O(log n) and O(n) for best and worst case scenario. As can be seen in the picture below for an unbalanced tree we might have to traverse through all nodes present hence the run time of O(n).\n\n![Binary Tree image](https://helloacm.com/wp-content/uploads/2016/04/balanced-tree-or-not.png)\n\nOne thing to make note of is that a balanced tree might not always be the best. For example if you're trying to see which has the best worst case for searches between a balanced tree with depth/height of 20 and unbalanced with 18. The best one in this case would be unbalanced with 18 as in the worst case only 19 comparisons will take place compared to the 21 required for the balanced tree.\n\nBut if you are searching for a particular value where both have the same number of nodes the best one would be an unbalanced tree.\n\nWhen creating a BST to maintain the propoerties of BST each node inserted has only one correct position it could go in assuming each value inserted is unique. Thus the order in which numbers are added into the BST does affect the performance of the BST. Adding a sorted data into BST has the worst runtime of O(n).\n","url":"https://nahombefekadu.github.io/Notes/notes\\IeIECqCpjnXdzzoXriTH2.html","relUrl":"notes\\IeIECqCpjnXdzzoXriTH2.html"},{"doc":"Balancing","title":"Balancing","hpath":"Data Structures.Binary Trees.Balancing","content":"\nWe know that a BST needs to be well balanced to give optimal performance and results, but there are different ways of balancing trees. Here\n\nOne way of balancing BSTs is a tree rotation, tree rotation changes the structure of the tree but does not affect the structure of the tree. Rotations are usually used to balance two branches of different depths.\n\nIn a rotation a node is shifted up while another node is shifted down. Other nodes may need to also be shifted to maintain the integrity of the binary tree. These rotations can change the height of the tree by moving large subtrees. As it can be seen below in both rotations the order of the nodes has not changed but the levels of the nodes has shifted.\n\nWe can also see that due to the rotation that the children of the nodes being rotated are also shifted but still stay the children of the nodes. Only thing changing the level/depth of these nodes. Thus we can see that this is a great way to balance trees as it does not matter if the node in rotation has parents. Hence we can use rotations at any level/depth within the tree.\n\n![Binary Tree image](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ3eL1D8i9Ukx3qguOLn8No8NugQm9fzDJ10g&usqp=CAU)\n\nIn the example below you can see that we can use rotations to make a tree that is unbalanced balanced by applying rotations.\n\n![Binary Tree image](https://cs2852uphoff.files.wordpress.com/2011/05/treerotationexample.png)\n\nFor the tree above after rotation has been applied the tree has been balanced. But balancing trees continually is not optimal hence **AVL** is applied.\n\n---\n\n## AVL\n\nAVL tree are a self balancing BST tree that applies rotation automatically as it's always balanced. Thus it is a much faster operation than most BSTs. When inserting a node the branch is inspected for balancing and the appropriate rotation is applied to make the tree balanced.\n\nAVL looks at pattern of the branches in a tree where insertion of a node is occurring and looks for four patterns.\n\n- Left-Left\n- Left-Right\n- Right-Left\n- Right-Right\n\nIt performs these rotations after insertion of a new node, applying rotation to the node one or two levels above it or both.\n\nLeft-Left(LL): In this operation a right rotation is performed on the node above the inserted node. As shown in the picture below the inserted node is moved up and the node two levels up is moved down.\n\n![Binary Tree image](https://www.tutorialspoint.com/data_structures_algorithms/images/avl_right_rotation.jpg)\n\nLeft-Right(LR): This is a multi step process where a left rotation on the node above the inserted node is applied moving the above node down and the inserted node up. After which a right rotation is applied on the node that was two levels above the inserted node, moving the inserted node up and the top node down.\n\n![Binary Tree image](https://miro.medium.com/max/1400/1*eYEkh7esJ1P6J0ggd0skmQ.png)\n\nRight-Left(RL): In this operation a right rotation is performed on the node above the inserted node moving the inserted node up and the above node down. After that a left rotation is performed on the node two that was above two levels the inserted node. moving the above node below the inserted node.\n\n![Binary Tree image](https://miro.medium.com/max/700/1*OSo3z-9G7-fY4oRu0u03aw.png)\n\nRight-Right(RR): In this operation a left rotation is performed on the node above the inserted node, moving it up and the node two levels up down.\n\n![Binary Tree image](https://www.tutorialspoint.com/data_structures_algorithms/images/avl_left_rotation.jpg)\n\nAs can be seen thus far balancing is really easy with AVL trees, But the downsides of AVL is insertion and deletions. In these cases they can be operationally heavy as several rotations per each operation can be required.\n\n---\n\n## RED-Black\n\nThere is another self balancing tree similar to AVL, the **red-black tree**. This algorithm does not have strict balancing requirements like AVL so its look up is slower than AVL, but its insertion and deletion operation are much faster due to requiring less rotations per operation.\n\n![Binary Tree image](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/316px-Red-black_tree_example.svg.png)\n\nHow these trees work is that each node in the tree is either red or black, where new inserted nodes are always marked red. After insertion the color of the surrounding nodes is assessed and the nodes are rotated or repainted to achieve the conditions below:\n\n- All red leaves must have only child nodes colored black.\n- the root of the tree must always be black\n- No matter where you are in the tree, every path to a leave/leaf node must go through the same number of black nodes.\n\nThe tree resulting from this algorithm is not perfectly balanced as AVL trees but its runtime operation for lookup is still O(log n) and for insertion and deletion.\n\nThis is due to the tree having a maximum total height of 2 log (n+1)\n\n#### Insertion\n\nWhen a new node is inserted into a red-black tree, the algorithm searches through the tree to find the correct spot based on the value and places the node(similar to BST) then paints the node red. After that is complete it assesses the surrounding nodes and performs either of these 4 actions:\n\n1. In the first case the new nodes parent is black, the red-black properties are upheld and nothing is done.\n\n2. The second case the new nodes parent and its siblings are painted red. Here you would switch the color of the parent and parent sibling node to black and switch the grandparent to the node to red.\n\n3. Here the new nodes parent is red and its sibling is black, and the new nodes value is between the parent and grandparent.\n\n   - If the new node is greater than the parent, the parent is rotated left, where as if the node is less than the parent the parent is rotated right.\n\n4. The last case is where the new nodes parent is red and the parent sibling is black. The parent node should be between the value of the new node and the grandparent.\n   - If the new node value is less than the parent, the grandparent is rotated right and the colors of the parent and grandparent are swapped.\n   - if the new node value is greater than the parent, the grandparent is rotated left and the colors are swapped.\n\nFor the tree below if we were to insert 7, based on rules of BST it will be inserted in the right branch of 6. After which we would follow the cases outlined above, The grandparent (1) is rotated left and the colors of grandparent and parent nodes and it's children are switched.\n\n![Binary Tree image](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/316px-Red-black_tree_example.svg.png)\n\nAnother example:\n\n![Binary Tree image](https://iq.opengenus.org/content/images/2018/07/red-black-tree_-insertion.jpg)\n\n---\n\nIn general AVL and red-black trees will have a faster runtime for lookup compared to BST and binary tree.\n\nThus we can say that if a runtime of a algorithm for lookup is closer to O(N) we know that it will not be AVL or red-black trees as their lookup time is guaranteed to be in O(log n).\n\nWhen looking at creating a tree and if we're choosing between AVL and red-black, we look and see if we will be doing lots of insertion and deletion operations if so the best bet is to go with red-black trees. But if the tree is static or unchanging the best tree to use would be AVL.\n","url":"https://nahombefekadu.github.io/Notes/notes\\dAIbJALaDi5GytOwdazz9.html","relUrl":"notes\\dAIbJALaDi5GytOwdazz9.html"},{"doc":"Arrays","title":"Arrays","hpath":"Data Structures.Arrays","content":"\n","url":"https://nahombefekadu.github.io/Notes/notes\\0WlW3iokuTpYX6JNGAQAS.html","relUrl":"notes\\0WlW3iokuTpYX6JNGAQAS.html"}]
