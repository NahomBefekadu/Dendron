{"pageProps":{"note":{"id":"WfdADQRT7cfzOlj1XR8Uz","title":"Binary Trees","desc":"","updated":1641184874028,"created":1641094892866,"custom":{},"fname":"data-structures.binary-trees","type":"note","vault":{"fsPath":"vault"},"contentHash":"2caf48c5303b63a8ddcb102242294397","links":[{"from":{"fname":"problems.binary-tree.branch-sums","vaultName":"vault"},"type":"backlink","position":{"start":{"line":99,"column":3,"offset":1744},"end":{"line":99,"column":35,"offset":1776},"indent":[]},"value":"data-structures.binary-trees","alias":"data-structures.binary-trees"},{"from":{"fname":"problems.binary-tree.tree-diameter","vaultName":"vault"},"type":"backlink","position":{"start":{"line":94,"column":3,"offset":1605},"end":{"line":94,"column":35,"offset":1637},"indent":[]},"value":"data-structures.binary-trees","alias":"data-structures.binary-trees"},{"from":{"fname":"problems.binary-tree.tree-sum","vaultName":"vault"},"type":"backlink","position":{"start":{"line":44,"column":3,"offset":604},"end":{"line":44,"column":35,"offset":636},"indent":[]},"value":"data-structures.binary-trees","alias":"data-structures.binary-trees"}],"anchors":{},"children":["dAIbJALaDi5GytOwdazz9","IeIECqCpjnXdzzoXriTH2","v4OODim5jeNuuURCTzWU5"],"parent":"rydiHYJbn3JhvGgWrK9Sl","data":{}},"body":"<h1 id=\"binary-trees\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#binary-trees\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Binary Trees</h1>\n<p><img src=\"/Dendron/assets/images/2022-01-02-23-35-49.png\"></p>\n<p>Binary Tree is a tree data structure in which each node has at most two children,left child and right child. Usually nodes in a tree can have multiple children but binary trees can have only two max. They are a useful data structure for storing data such as numbers and allow for fast lookup using binary search functionality.</p>\n<p>the number of children each node has in a tree is called branching factor, and as such a binary tree has a branching factor of 2.</p>\n<p>Similar to linked list a binary tree has a node which contains a value and a pointer to another node. But in a binary tree it has two pointers one for the left child and one for the right child.</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">BST</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">value</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">left</span> <span class=\"token operator\">=</span> <span class=\"token keyword null nil\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">right</span> <span class=\"token operator\">=</span> <span class=\"token keyword null nil\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img src=\"/Dendron/assets/images/2022-01-02-23-36-06.png\"></p>\n<p>A binary tree uis made up of nodes and links/edges, The nodes represent the data stored in the tree, and the node at the top is called the root while every other node is a child node or a parent node. The nodes which point to no other node are called Leaf nodes. Nodes which have the same parent are called sibling nodes.</p>\n<p>In general the number of nodes present in a tree will be one more than the number of edges/links present. Thus you can find the number of nodes present by counting the number of edges and adding one.</p>\n<p>Below you can find how simple it is to search though a binary tree.\n<a href=\"https://blog.penjee.com/wp-content/uploads/2015/11/binary-search-tree-sorted-array-animation.gif\">https://blog.penjee.com/wp-content/uploads/2015/11/binary-search-tree-sorted-array-animation.gif</a></p>\n<p><img src=\"/Dendron/assets/images/2022-01-02-23-36-53.png\"></p>\n<hr>\n<p>Another thing to pay attention for binary trees is the depth, node height, and tree height. To maximize efficiency of searching for an element in the tree.</p>\n<p>We say that the <strong>depth</strong> of a node is the number of links from the root to the node. Thus the root node has a depth of zero and its direct children have a depth of 1.</p>\n<p>We say that the <strong>height</strong> of a tree is the depth of the deepest node present in the tree from the root node. When we want to find a specific <strong>node height</strong> we look at the number of edges present from that node to a leaf node.</p>\n<p>To find the maximum/larges number of nodes a binary tree can have we use this formula: 2^(height or n) - 1 max nodes possible at each tree height.</p>\n<p><img src=\"/Dendron/assets/images/2022-01-02-23-40-55.png\"></p>\n<p>A given binary tree can be a full or complete binary tree. When we say a full binary tree we mean that each node has either exactly zero or two children. Since every node has to point to at least two nodes after the root node, a full binary tree cannot have an even number of nodes.</p>\n<p>Whereas a complete binary tree is completely filled(except the last level sometimes) and is made so that all given sub nodes are as far left as possible.</p>\n<p><img src=\"/Dendron/assets/images/2022-01-02-23-41-09.png\"></p>\n<hr>\n<h2 id=\"backlinks\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#backlinks\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Backlinks</h2>\n<ul>\n<li><a href=\"/Dendron/notes/p9MhOqyMCZX5Gy9vcGV0O\">Branch Sums</a></li>\n<li><a href=\"/Dendron/notes/yV0szi3GGyuHyEbGYz3NZ\">Tree Diameter</a></li>\n<li><a href=\"/Dendron/notes/SimMK6mMAWR4H53Xqh9XB\">Tree Sum</a></li>\n</ul>\n<hr>\n<h2 id=\"children\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#children\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Children</h2>\n<ol>\n<li><a href=\"/Dendron/notes/dAIbJALaDi5GytOwdazz9\">Balancing</a></li>\n<li><a href=\"/Dendron/notes/IeIECqCpjnXdzzoXriTH2\">Search Trees</a></li>\n<li><a href=\"/Dendron/notes/v4OODim5jeNuuURCTzWU5\">Traverse</a></li>\n</ol>","noteIndex":{"id":"vVFnvX3AZLb21JIc7L4gm","title":"Root","desc":"","updated":1641184503497,"created":1640015760017,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"dbe76e060067b9059e208c353b2be0be","links":[],"anchors":{"computer-science-library":{"type":"header","text":"Computer Science Library","value":"computer-science-library","line":8,"column":0,"depth":1}},"children":["Yvra9LpGoPLi4Kk2KKGsK","jL0XOOMd1sy4tgf2SWfg5","rydiHYJbn3JhvGgWrK9Sl","l8rNoqR6OrTiJzqzAsfms","Zd60tpALGBOrNJC2avO70","aVtnDm5TBmQfxOgRoc0m1","gh9HX9yN4MF2djOLFCV3N","BeyqjmB3iu9oewp7hCpqg","PbPnrOhcARThoz7ymnam8"],"parent":null,"data":{},"body":"\n# Computer Science Library\n\nThis is a collection of notes ranging from data structures and problems to specific knowledge of a programming language. It is a stored knowledge of different programming languages and applications for easy retrieval and note keeping.\n\nThis repository will be continually updated and maintained as knowledge base grows and aspects of languages are updated.\n\n![](/assets/images/2022-01-02-23-34-36.png)\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":4,"useFMTitle":true,"useNoteTitleForLink":true,"mermaid":true,"useKatex":true,"dev":{"enablePreviewV2":true},"site":{"assetsPrefix":"/Dendron","siteUrl":"https://nahombefekadu.github.io","copyAssets":true,"siteHierarchies":["root"],"siteRootDir":"docs","usePrettyRefs":true,"title":"Dendron","description":"Personal knowledge space","siteLastModified":true,"gh_edit_branch":"main","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"usePrettyLinks":true,"siteNotesDir":"notes","siteFaviconPath":"favicon.ico","gh_edit_link":true,"gh_edit_link_text":"Edit this page on GitHub","gh_root":"docs/","gh_edit_view_mode":"edit","writeStubs":true,"siteIndex":"root"},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{}},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false}}},"__N_SSG":true}