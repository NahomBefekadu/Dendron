
Collection of Data Structure and Algorithm Problems, with explanation and solution in both java and javascript with links to concepts that pertain to the problem.

Most questions present have an obvious pattern, can be broken down to it's basic pattern. The first step is always brute force but we can follow these patterns into optimizing our solutions. These patterns usually lead you to the most optimal solution time complexity wise.

## Patterns

1. Sliding Window
2. Two Pointers / Iterators
3. Fast and Slow Pointers
4. Merge Intervals
5. Cyclic Sort
6. In-Place Reversal of Linked Lists
7. Tree BFS/DFS
8. Two Heaps
9. Subsets
10. Binary Search
11. Top K Elements
12. K-Way Merge
13. Topological Sort

- If you have a problem with sorted arrays/linked lists and need to find a set of elements: **Two Pointers**.
- If you have a problem with arrays/linked list and and need to find /calculate something among subarrays/sublists: **Sliding Window**.
- if you have a problem with cyclic arrays/linked lists: **Fast & Slow Pointers**.
- If you have a problem which deals with intervals (overlapping/merging): **Merge Intervals**.
- If you have a problem with arrays and a given range and asked to find missing elements etc..: **Cyclic Sort**.
- If you have a problem with linked list and asked to reverse nodes: **In-Place Reversal of Linked Lists**.
- If you have a problem with traversing a tree like structure in a level/depth order: **Breadth First Search**.
- If you have a problem requiring exploring depth of a path, etc.. : **Depth First Search**.
- If you have a problem where it can be divided into two parts(min and max): **Two Heaps**.
- If you have a problem involving permutations/combinations of elements: **Subsets(efficient BFS)**.
- If you have a problem with sorted array/linkedlist/matrix and need to find a specific element: **Binary Search**.
- If you have a problem involving solving same problems repeatedly(dynamic): **Dynamic Programming(Knapsack)**.
- If you have a problem involving bits or finding missing numbers: **Bitwise XOR**.
- If you have a problem involving finding a linear order of elements that depend on each other: **Topological Sort**.
- if you have a problem with sorted list of arrays: **K-way Merge**.
- if you have a problem involving finding the top/smallest/frequent k elements in a set: **Top K Elements**.

## Other Strategies

- Array and String We can use two pointers, HashMap and HashSet.

- If problem involves something where an array is sorted, we can use either a binary search or two pointer method.

- If it involves a linked list we can use a two pointer approach

- If it involves a Tree or a Graph we can use DFS, and BFS

- if problem asks for (Frequency/counter/duplicates/common string) think about using maps

- if problem asks for (Top/ Least K Items) think about using Heap

- if problem asks for (Maximum/minimum/subarray/subs etc..) think about using Dynamic Programming

- if problem asks for (Permutation/Subsets) think about using Back Tracking

- if problem asks for (Recursion is prohibited) think about using Stack

- if problem asks for (common String) think about using Map or Trie
