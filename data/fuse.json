{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Root","n":1},"1":{"v":"\n# Computer Science Library\n\nThis is a collection of notes ranging from data structures and problems to specific knowledge of a programming language. It is a stored knowledge of different programming languages and applications for easy retrieval and note keeping.\n\nThis repository will be continually updated and maintained as knowledge base grows and aspects of languages are updated.\n\n![](/assets/images/2022-01-02-23-34-36.png)\n","n":0.134}}},{"i":2,"$":{"0":{"v":"Templates","n":1}}},{"i":3,"$":{"0":{"v":"Questions","n":1},"1":{"v":"\n## Question\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    2-->6;\n    2-->7;\n    3-->4;\n    3-->8;\n```\n\n#### Output:\n\n## Solution\n\n#### Javascript\n\n```javascript\n\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n## Patterns\n","n":0.25}}},{"i":4,"$":{"0":{"v":"Problems to Do","n":0.577},"1":{"v":"\n## To Do\n\n- [ ]\n- [ ]\n- [ ]\n- [ ]\n- [ ]\n- [ ]\n- [ ]\n- [ ]\n- [ ]\n","n":0.218}}},{"i":5,"$":{"0":{"v":"Scratch","n":1}}},{"i":6,"$":{"0":{"v":"2022","n":1}}},{"i":7,"$":{"0":{"v":"01","n":1}}},{"i":8,"$":{"0":{"v":"06","n":1}}},{"i":9,"$":{"0":{"v":"122305","n":1}}},{"i":10,"$":{"0":{"v":"Deploy Jar","n":0.707},"1":{"v":"\n- right click target and select open in terminal\n\n* then type java -jar {the jar name start of it then can press tab to autocomplete}\n\nAfter that the server is deployed.\n\napplication.properties is where you define your connection details.\n\nflyaway is for database migrations, manage db schema as we evolve\n\nto create the database inside of the docker instance we are using so we can use the name of the db in our java app.\n\nwe have to remove into the contianer and create the DB\n\nwe do that by\n\n```terminal\ndocker exec -it {CONTAINER ID} bin/bash\n\npsql -U {username}\n\n\n\\l\n\nCREATE DATABASE {name}\n\n\\c {db name}\n\n\\d\n\\dt\n```\n\nthe second line logs in to postgress as user\n\nthe third line lists all the database currently have\n\nconnect to the database using the fourth command\n\n5 and 6 are used for describing the database 5 is for everything 6 is just for tables\n","n":0.086}}},{"i":11,"$":{"0":{"v":"Projects & Websites","n":0.577}}},{"i":12,"$":{"0":{"v":"Operating System","n":0.707},"1":{"v":"\n- [ ] Linux section\n- [ ] Assembly\n","n":0.354}}},{"i":13,"$":{"0":{"v":"Front End","n":0.707},"1":{"v":"\n- [ ] HTML\n- [ ] CSS\n- [ ] SASS\n- [ ] Links to resources?\n- [ ] inspo board\n- [ ] Colors/ color theory\n","n":0.204}}},{"i":14,"$":{"0":{"v":"Frameworks and Architecture","n":0.577},"1":{"v":"\n- [ ] Node.js\n- [ ] Git/ Github\n- [ ] Travis CLI\n- [ ] Express\n- [ ] Spring\n- [ ] Firebase\n- [ ] Stripe\n- [ ] React\n- [ ] Angular\n- [ ] Database section\n- [ ] API section\n- [ ] Docker\n- [ ] Kubernetes\n- [ ] API documentations\n","n":0.144}}},{"i":15,"$":{"0":{"v":"Spring","n":1},"1":{"v":"\nThe following link below allows us to bootstrap our java project easily, and is a great way to start the project.\n\nhttps://start.spring.io/\n\n[[deploy jar\n|scratch.2022.01.06.122305.deploy-jar]]\n","n":0.213}}},{"i":16,"$":{"0":{"v":"Data Structures","n":0.707}}},{"i":17,"$":{"0":{"v":"Stacks","n":1},"1":{"v":"\nStacks contain data nodes, and they follow the principles of Last in First out(LIFO) order.\n\nStacks can be implemented using either an array or linked list, and support three main operations of adding data to the top of the stack, removing and providing data from top of the stack, and finally peek which reveals the data on top of the stack.\n\nStacks can also have a size limit, where if data is pushed into a full stack it will result in a stack overflow.\n\nReal life situation of a stack is a line at a grocery store, where the first in line is checked out, and new comers are last in.\n\nBelow we can see that we can create a stack from a linked list, but we can also create a stack from an array as well.\n\n```javascript\nconst LinkedList = require(\"./LinkedList\");\n\nclass Stack {\n  constructor(maxSize = Infinity) {\n    this.stack = new LinkedList();\n    this.maxSize = maxSize;\n    this.size = 0;\n  }\n\n  hasRoom() {\n    return this.size < this.maxSize;\n  }\n\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  push(value) {\n    if (this.hasRoom()) {\n      this.stack.addToHead(value);\n      this.size++;\n    } else {\n      throw new Error(\"Stack is full\");\n    }\n  }\n\n  pop() {\n    if (!this.isEmpty()) {\n      const value = this.stack.removeHead();\n      this.size--;\n      return value;\n    } else {\n      throw new Error(\"Stack is empty\");\n    }\n  }\n\n  peek() {\n    if (!this.isEmpty()) {\n      return this.stack.head.data;\n    } else {\n      return null;\n    }\n  }\n}\n```\n","n":0.067}}},{"i":18,"$":{"0":{"v":"Sorting","n":1}}},{"i":19,"$":{"0":{"v":"Recursion","n":1},"1":{"v":"\nRecursion is useful for many other data structures and computer programs. One of the best examples of recursion is the fibonacci sequence.\n\n```javascript\nlet fibonacci = function (f) {\n  if (f < 0) {\n    console.log(\"index error\");\n  } else if (f == 0) {\n    return 0;\n  } else if (f == 1) {\n    return 1;\n  }\n  let fn = [0, 1];\n  for (let i = 2; i < f + 1; i++) {\n    fn.push(fn[i - 1] + fn[i - 2]);\n  }\n  return fn[f];\n};\n\nlet j = fibonacci(9);\nconsole.log(j);\n//34\n```\n\nTo see how the call stacks work lets take a look at calling the function fibonacci(4).\n\nThis would result in the function being called nine times, as it recursively calls the function each time as shown below.\n\n```terminal\nF(4) - F(3)  - F(2) - F(1)\n       F(3)  - F(2) - F(1)\n               F(2) - F(1)\n```\n","n":0.087}}},{"i":20,"$":{"0":{"v":"Queues","n":1},"1":{"v":"\nQueues can be implemented using various data structures the main one being singly linked lists. Queues contain data nodes and have three modes of operations. Queues operate on the principle of FIFO which is first in first out.\n\nEnqueue adds data to the back of the queue, Dequeue removes and provides the data from the front of the queue, and lastly peek provides the data on the front of the queue\n\nWhen working with queues Enqueueing onto a full queue would causes a queue overflow to occur. In the opposite cause dequeuing data from an empty queue can cause an underflow to occur.\n\nBonded queues also have a limited size, they are queues which limit the number of nodes they can have. as for other methods of employing a queue an array can be used to implement one as well.\n\nBelow you can see two example queues where one has a maximum size and the other one is a simpler implementation of queues.\n\n```javascript\nconst LinkedList = require(\"./LinkedList\");\n\nclass Queue {\n  constructor() {\n    this.queue = new LinkedList();\n    this.size = 0;\n  }\n\n  enqueue(data) {\n    this.queue.addToTail(data);\n    this.size++;\n    console.log(`Added ${data} to queue! Queue size is now ${this.size}.`);\n  }\n\n  dequeue() {\n    const data = this.queue.removeHead();\n    this.size--;\n    console.log(`Removed ${data} from queue! Queue size is now ${this.size}.`);\n    return data;\n  }\n}\n\nmodule.exports = Queue;\n```\n\n```javascript\nconst LinkedList = require(\"./LinkedList\");\n\nclass Queue {\n  constructor(maxSize = Infinity) {\n    this.queue = new LinkedList();\n    this.maxSize = maxSize;\n    this.size = 0;\n  }\n\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  hasRoom() {\n    return this.size < this.maxSize;\n  }\n\n  enqueue(data) {\n    if (this.hasRoom()) {\n      this.queue.addToTail(data);\n      this.size++;\n      console.log(`Added ${data} to queue! Queue size is now ${this.size}.`);\n    } else {\n      throw new Error(\"Queue is full!\");\n    }\n  }\n\n  dequeue() {\n    if (!this.isEmpty()) {\n      const data = this.queue.removeHead();\n      this.size--;\n      console.log(\n        `Removed ${data} from queue! Queue size is now ${this.size}.`\n      );\n      return data;\n    } else {\n      throw new Error(\"Queue is empty!\");\n    }\n  }\n}\n\nmodule.exports = Queue;\n```\n","n":0.057}}},{"i":21,"$":{"0":{"v":"Linked List","n":0.707},"1":{"v":"\nLinked Lists are Linear Data Structures that hold data in nodes, and where each element is arranged/stored sequentially. But they are also recursive data structures as linked lists are composed of smaller instances of themselves(nodes). The data they held by the node is composed of a value and a pointer to another node.\n\nHow do linked lists then differ from an array, well we know that in an array all the data has to be continuous in memory. But in the case of linked list all the data it contains do not have be next to each other in memory.\n\nSingle Linked List\n\n```mermaid\ngraph TD;\nA[value:A next:B] --> B[value:B next:null]\n\n```\n\nDoubly Linked List\n\n```mermaid\ngraph TD;\nA[value:A next:B previous:null] --> B[value:B next:null previous:A]\nB[value:B next:null previous:A] --> A\n\n```\n\nWhen looking at the linked list we can see that it has an insertion of O(1) but comparatively worse look up time of (n). This look up time is related to the fact that you have to traverse the linked list to find the right insertion or lookup point. As to get the 50th element in a linked list, you would have to traverse 49 nodes from the head node to reach it.\n\n## Traversal\n\nNow we can traverse through a given linked lists two ways either iteratively or recursively. we can look at a simple function to print a given linked list.\n\n```javascript\n// iteratively\nconst printLinkedList = (head) => {\n  current = head;\n  while (current !== null) {\n    console.log(current.data);\n    current = current.next;\n  }\n};\n//recursively\nconst PrintLinkedList = (head) => {\n  current = head;\n  if (current === null) return;\n  console.log(current.data);\n  PrintLinkedList(current.next);\n};\n```\n","n":0.063}}},{"i":22,"$":{"0":{"v":"Single Linked List","n":0.577},"1":{"v":"\n# Linked Lists\n\nIn javascript Linked lists use the Node class, which can also be imported from Node.js\n\nBelow is the structure for a Node class that can be used to create linked lists.\n\n**this.next** property is used to keep track of the following node.\n\n**this.data** property is used to hold the data of the node.\n\n## Node\n\n```javascript\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n\n  setNextNode(node) {\n    if (node instanceof Node || node === null) {\n      this.next = node;\n    } else {\n      throw new Error(\"Next node must be a member of the Node class.\");\n    }\n  }\n\n  getNextNode() {\n    return this.next;\n  }\n}\n```\n\nwe can use this Node class to create a list of nodes connected with each other and we can do that by creating a node and setting its next node property.\n\n```javascript\nconst FirstNode = new Node('I\"m first node');\nconst SecondNode = new Node('I\"m second node');\nconst ThirdNode = new Node('I\"m third node');\n\nFirstNode.setNextNode(SecondNode);\nSecondNode.setNextNode(ThirdNode);\n```\n\nso when creating a linked list we would go about first importing the Node class.\n\n```javascript\nconst Node = require(\"./Node\");\n```\n\nSo that's the base structure for a Node now how do we go about creating a linked list, first as stated above we call our Node module created previous and we create a LinkedList class.\n\n## LinkedList\n\nThis is our class created for our linked list, we first create a constructor and set our head value for our linked list to **null**\n\n```javascript\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n}\n```\n\n#### Adding\n\nAfter that we need a way in which we can add a new node and data into our created linked list, so we create a method to create a set of nodes.\n\nThe add to head method works by first creating a new Node using the module we imported and created previously, from there we create a variable to hold the current head state of the linked list and set that to **this.head** which refers to the object created.\n\nAs we are adding a new node to our head we need to set our currenthead in our list as the NextNode to the new value being added in, essentially our new node pushes the current head down so that there is something new pointing to it.\n\n```javascript\naddToHead(data) {\n    const newHead = new Node(data);\n    const currentHead = this.head;\n    this.head = newHead;\n    if (currentHead) {\n      this.head.setNextNode(currentHead);\n    }\n  }\n```\n\nWe have our method to add a new node into the head of our linked list but linked lists can also add a new node from the tail of a linked list so we need to create a similar method for adding to the tail.\n\nWhen we add a new node to our tail we first check if there is any node value currently, if not we set our new node at that location if not we loop through our linked list until we have reached the point where the currentnode we're at has a null value for its next node at that point we create a new node at that point, with the current node we're on pointing to that node. This is because this data structure only keeps track of the head of the list hence the need to traverse this list to add to the tail.\n\n```javascript\naddToTail(data) {\n    let tail = this.head;\n    if (!tail) {\n      this.head = new Node(data);\n    } else {\n      while (tail.getNextNode() !== null) {\n        tail = tail.getNextNode();\n      }\n      tail.setNextNode(new Node(data));\n    }\n  }\n```\n\n#### Removing\n\nWe have our two methods for adding new nodes into our list but we now need a method to remove a node from the list.\n\nwhen we remove a node, we first set a variable to hold the currentNode, and we first check if there is anyvalue at that current node, if there is no value we return from our function. if not we set the current head to the nextnode of the current node and return the data.\n\n```javascript\n removeHead() {\n    const removedHead = this.head;\n    if (!removedHead) {\n      return;\n    }\n    this.head = removedHead.getNextNode();\n    return removedHead.data;\n  }\n```\n\nwe can also add a method to be able to see our whole linked list in one command, thats the method for printList it removes the need to have multiple console log methods to print your linked list every time its updated.\n\n#### Print\n\n```javascript\n  printList() {\n    let currentNode = this.head;\n    let output = '<head> ';\n    while (currentNode !== null) {\n      output += currentNode.data + ' ';\n      currentNode = currentNode.getNextNode();\n    }\n    output += '<tail>';\n    console.log(output);\n  }\n```\n\n## Example of Linked Lists\n\nwe have created the necessary classes to implement a LinkedList now we can use those classes to create a linked list by creating an instance of that class.\n\nour first example consists of creating a simple stringed list of \"one\" \"two\" etc.. and we will use the tools to build a list of these string values\n\n```javascript\nconst LinkedList = require(\"./LinkedList\");\n\nconst Numbers = new LinkedList();\nNumbers.printList();\nNumbers.addToHead(\"One\");\nNumbers.addToHead(\"Two\");\nNumbers.printList();\nNumbers.addToTail(\"Three\");\nNumbers.addToTail(\"Four\");\nNumbers.printList();\nNumbers.removeHead();\nNumbers.printList();\n\n/*\nThe out put of this function will be \n<head> <tail>\n<head> Two One <tail>\n<head> Two One Three Four <tail>\n<head> One Three Four <tail>\n\n*/\n```\n","n":0.035}}},{"i":23,"$":{"0":{"v":"Double Linked List","n":0.577},"1":{"v":"\n# Linked Lists\n\nIn javascript Linked lists use the Node class, which can also be imported from Node.js\n\nBelow is the structure for a Node class that can be used to create linked lists.\n\n**this.next** property is used to keep track of the following node.\n\n**this.data** property is used to hold the data of the node.\n\n## Node\n\n```javascript\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n\n  setNextNode(node) {\n    if (node instanceof Node || node === null) {\n      this.next = node;\n    } else {\n      throw new Error(\"Next node must be a member of the Node class.\");\n    }\n  }\n\n  getNextNode() {\n    return this.next;\n  }\n}\n```\n\nwe can use this Node class to create a list of nodes connected with each other and we can do that by creating a node and setting its next node property.\n\n```javascript\nconst FirstNode = new Node('I\"m first node');\nconst SecondNode = new Node('I\"m second node');\nconst ThirdNode = new Node('I\"m third node');\n\nFirstNode.setNextNode(SecondNode);\nSecondNode.setNextNode(ThirdNode);\n```\n\nso when creating a linked list we would go about first importing the Node class.\n\n```javascript\nconst Node = require(\"./Node\");\n```\n\nSo that's the base structure for a Node now how do we go about creating a linked list, first as stated above we call our Node module created previous and we create a LinkedList class.\n\n## Doubly Linked Lists\n\nSimilar to linked lists doubly linked lists comprise of nodes as well, the change is that they contain two pointer now which point to the next node similar to a linked list and a new addition a pointer to the previous node.\n\npreviously when we created our next node it was pointing to null similarly for our previous node it will point to null as well , this is useful as doubly linked lists make traversal of the list easier.\n\na bus route is similar to a doubly linked list with its stops serving as nodes, you can start from the head node and go down to the end of the stop and take the bus in reverse to go back to the starting point.\n\n### Node\n\nthis is the node class which we will use to create our doubly linked list, it's similar to the previous node but we've added the functionality of previous pointer.\n\n```javascript\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n    this.previous = null;\n  }\n\n  setNextNode(node) {\n    if (node instanceof Node || node === null) {\n      this.next = node;\n    } else {\n      throw new Error(\"Next node must be a member of the Node class\");\n    }\n  }\n\n  setPreviousNode(node) {\n    if (node instanceof Node || node === null) {\n      this.previous = node;\n    } else {\n      throw new Error(\"Previous node must be a member of the Node class\");\n    }\n  }\n\n  getNextNode() {\n    return this.next;\n  }\n\n  getPreviousNode() {\n    return this.previous;\n  }\n}\n\nmodule.exports = Node;\n```\n\n#### Adding\n\nWhen we add nodes to doubly linked list we have to take care and keep track of the two pointers we now have.\n\nif we are adding to the head of the list we need to first check as always if there is a current head to the list, if there's none it becomes simple we just add a node where both the pointers are set to null. If not then we have to set the **current heads** previous pointer to our **new head** and set the next pointer of our **new head** to the **current head**, and we set the **new head**'s previous pointer to null.\n\nif we are adding to the tail similar to the head we check if list is empty following the same process as the head, if its not empty we set the current **tails** next pointer to the **new tail**, set the **new tail** previous to the **current tail**, and set the **new tails** next pointer to null.\n\nAdd to Head:\n\n```javascript\n addToHead(data){\n    const newHead= new Node(data);\n    const currentHead=this.head;\n    if (currentHead){\n      currentHead.setPreviousNode(newHead);\n      newHead.setNextNode(currentHead);\n    }\n    this.head=newHead;\n    if (!this.tail){\n      this.tail=newHead;\n    }\n  }\n\n```\n\nAdd to Tail:\n\n```javascript\n  addToTail(data){\n    const newTail = new Node(data);\n    const currentTail = this.tail;\n    if (currentTail){\n      currentTail.setNextNode(newTail);\n      newTail.setPreviousNode(currentTail);\n    }\n    this.tail=newTail;\n    if(!this.head){\n      this.head=newTail;\n    }\n  }\n\n```\n\n#### Removing\n\nwhen removing the head we have to set the previous pointer of the new head to null. if we are removing the tail we have to set the next pointer of the new tail to null. if there was only one single element in the list both processes will occur.\n\nNow with double linked list we can remove a node from the middle of the list, that's one of the benefits. To do that we must set the removed nodes previous pointer to the following node after it, and we also must set the next node of the perceding node to its preceeding node.\n\nFor better clarity if B is removed we set the previous pointer of C from B to A, and we set the next pointer of A from B to C.\n\nA <-> B <-> C\n\nA <-> C\n\nRemove from Head:\n\n```javascript\nremoveHead() {\n    const removedHead = this.head;\n    if (!removedHead) {\n      return;\n    }\n    this.head = removedHead.getNextNode();\n    if (this.head) {\n      this.head.setPreviousNode(null);\n    }\n    if (removedHead === this.tail) {\n      this.removeTail();\n    }\n    return removedHead.data;\n  }\n\n```\n\nRemove from Tail:\n\n```javascript\n  removeTail() {\n    const removedTail = this.tail;\n    if (!removedTail) {\n      return;\n    }\n    this.tail = removedTail.getPreviousNode();\n    if (this.tail) {\n      this.tail.setNextNode(null);\n    }\n    if (removedTail === this.head) {\n      this.removeHead();\n    }\n    return removedTail.data;\n  }\n```\n\n#### Removing using Data\n\nwe first have to find a way to find the data we want to remove within our list, so the code below shows exactly that.\n\n```javascript\n  removeByData(data){\n    let nodeToRemove;\n    let currentNode = this.head;\n    while(currentNode){\n      if (currentNode.data===data){\n        nodeToRemove=currentNode;\n        break;\n      }\n      currentNode=currentNode.getNextNode();\n    }\n    if (!nodeToRemove){\n      return null;\n    }\n  }\n```\n\nnow that we have found our given node that we would like to remove we have to remove it from our list, so we add to the code we already have from before.\n\n```javascript\nremoveByData(data) {\n    let nodeToRemove;\n    let currentNode = this.head;\n    while (currentNode !== null) {\n      if (currentNode.data === data) {\n        nodeToRemove = currentNode;\n        break;\n      }\n      currentNode = currentNode.getNextNode();\n    }\n    if (!nodeToRemove) {\n      return null;\n    }\n\n    if(nodeToRemove===this.head){\n      this.removeHead();\n    }else if (nodeToRemove===this.tail){\n      this.removeTail();\n    }else{\n      const nextNode = nodeToRemove.getNextNode();\n      const previousNode=nodeToRemove.getPreviousNode();\n      nextNode.setPreviousNode(previousNode);\n      previousNode.setNextNode(nextNode);\n    }\n    return nodeToRemove;\n\n  }\n```\n\n## Example of Doubly Linked Lists\n\n```javascript\nconst DoublyLinkedList = require(\"./DoublyLinkedList.js\");\n\nconst Bus = new DoublyLinkedList();\n\nBus.addToHead(\"Stop 3\");\nBus.addToHead(\"Stop 2\");\nBus.addToHead(\"Stop 1\");\nBus.printList();\n\nBus.addToTail(\"Stop 4\");\nBus.addToTail(\"Stop 5\");\nBus.addToTail(\"Stop 6\");\nBus.printList();\n\nBus.removeHead();\nBus.removeTail();\nBus.printList();\n\nBus.removeByData(\"Stop 4\");\nBus.printList();\n\n/*\nOutPut:\n\n<head> Stop 1 Stop 2 Stop 3 <tail>\n<head> Stop 1 Stop 2 Stop 3 Stop 4 Stop 5 Stop 6 <tail>\n<head> Stop 2 Stop 3 Stop 4 Stop 5 <tail>\n<head> Stop 2 Stop 3 Stop 5 <tail>\n*/\n```\n","n":0.031}}},{"i":24,"$":{"0":{"v":"Hash Maps","n":0.707},"1":{"v":"\nHash maps map keys to the corresponding values, and is a very efficient way to retrieve stored data. The keys stored allow for this fast lookup time. Thus hash maps are useful data structure for problems which require storing and retrieving data.\n\nHash maps are built on top of arrays with a special index system, hash maps accomplish this by using a hash function which turns a key into an index for the array. The hash function.\n\nSometimes a hash function can give the same index for two different keys when that occurs a hash collision happens. There are two strategies to solve this one of them is separate chaining, where it avoids collisions by updating the underlying data structure. Instead of an array of values that are mapped to by hashes, it could be an array of linked lists! where each array index points to a different data structure and open addressing, to distinguish between different keys we store the the keys and values in the linked lists.\n\nThe down sides of separate chaining is that if the hash function gives the same key multiple times growing the linked list for the given key thus increasing the lookup time. This can be seen in the image below.\n\n![](/assets/images/2022-01-09-20-49-39.png)\n\nAnother strategy is open addressing. In this case we don't use a linked list as the underlying data structure but stick to arrays. But instead when we receive the same key we instead look for a different index to save our data until an empty index is present. Meaning that if our probing sequence is set to 2 we increment the given key value by 2 until an empty index is present.\n\nFor example below if we want to insert the value 8 in our function and it gives us 4 as the key there is a collision, but since we set our probe to two it will increment key value by 2 until we find an empty index.\n\n```terminal\n   Index values\n    0    1      2    3    4    5     6    7\n[ null, null, null, null, 14, null, 36, null]\n                          4 = collision\n                                    3+2 = collision\n        (6+2)-7=1 = no collision set value\n\n\n```\n\nThere are other strategies available for dealing with collisions but they can get very complex, and even the hash function shown already can cause problems such as clustering. Which is what happens when a collision causes more collisions.\n\n- **Hash map**: A key-value store that uses an array and a hashing function to save and retrieve values.\n- **Key**: The identifier given to a value for later retrieval.\n- **Hash function**: A function that takes some input and returns a number.\n- **Compression function**: A function that transforms its inputs into some smaller range of possible outputs.\n\n![](/assets/images/2022-01-09-20-47-01.png)\n\nRecipe for saving to a hash table:\n\n- Take the key and plug it into the hash function, getting the hash code.\n- Modulo that hash code by the length of the underlying array, getting an array index.\n- Check if the array at that index is empty, if so, save the value (and the key) there.\n- If the array is full at that index continue to the next possible position depending on your collision strategy.\n\nRecipe for retrieving from a hash table:\n\n- Take the key and plug it into the hash function, getting the hash code.\n- Modulo that hash code by the length of the underlying array, getting an array index.\n- Check if the array at that index has contents, if so, check the key saved there.\n- If the key matches the one you're looking for, return the value.\n- If the keys don't match, continue to the next position depending on your collision strategy.\n\n```javascript\nconst LinkedList = require(\"./LinkedList\");\nconst Node = require(\"./Node\");\nclass HashMap {\n  constructor(size = 0) {\n    this.hashmap = new Array(size).fill(null).map(() => new LinkedList());\n  }\n\n  hash(key) {\n    let hashCode = 0;\n    for (let i = 0; i < key.length; i++) {\n      hashCode += hashCode + key.charCodeAt(i);\n    }\n    return hashCode % this.hashmap.length;\n  }\n\n  assign(key, value) {\n    const arrayIndex = this.hash(key);\n    const linkedList = this.hashmap[arrayIndex];\n    console.log(`Storing ${value} at index ${arrayIndex}`);\n    if (linkedList.head === null) {\n      linkedList.addToHead({ key, value });\n      return;\n    }\n    let current = linkedList.head;\n    while (current) {\n      if (current.data.key === key) {\n        current.data = { key, value };\n      }\n      if (!current.next) {\n        current.next = new Node({ key, value });\n        break;\n      }\n      current = current.next;\n    }\n  }\n\n  retrieve(key) {\n    const arrayIndex = this.hash(key);\n    let current = this.hashmap[arrayIndex].head;\n    while (current) {\n      if (current.data.key === key) {\n        console.log(\n          `\\nRetrieving ${current.data.value} from index ${arrayIndex}`\n        );\n        return current.data.value;\n      }\n      current = current.next;\n    }\n    return null;\n  }\n}\n\nmodule.exports = HashMap;\n```\n","n":0.037}}},{"i":25,"$":{"0":{"v":"Binary Trees","n":0.707},"1":{"v":"\n![](/assets/images/2022-01-02-23-35-49.png)\n\nBinary Tree is a tree data structure in which each node has at most two children,left child and right child. Usually nodes in a tree can have multiple children but binary trees can have only two max. They are a useful data structure for storing data such as numbers and allow for fast lookup using binary search functionality.\n\nthe number of children each node has in a tree is called branching factor, and as such a binary tree has a branching factor of 2.\n\nSimilar to linked list a binary tree has a node which contains a value and a pointer to another node. But in a binary tree it has two pointers one for the left child and one for the right child.\n\n```javascript\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n```\n\n![](/assets/images/2022-01-02-23-36-06.png)\n\nA binary tree uis made up of nodes and links/edges, The nodes represent the data stored in the tree, and the node at the top is called the root while every other node is a child node or a parent node. The nodes which point to no other node are called Leaf nodes. Nodes which have the same parent are called sibling nodes.\n\nIn general the number of nodes present in a tree will be one more than the number of edges/links present. Thus you can find the number of nodes present by counting the number of edges and adding one.\n\nBelow you can find how simple it is to search though a binary tree.\nhttps://blog.penjee.com/wp-content/uploads/2015/11/binary-search-tree-sorted-array-animation.gif\n\n![](/assets/images/2022-01-02-23-36-53.png)\n\n---\n\nAnother thing to pay attention for binary trees is the depth, node height, and tree height. To maximize efficiency of searching for an element in the tree.\n\nWe say that the **depth** of a node is the number of links from the root to the node. Thus the root node has a depth of zero and its direct children have a depth of 1.\n\nWe say that the **height** of a tree is the depth of the deepest node present in the tree from the root node. When we want to find a specific **node height** we look at the number of edges present from that node to a leaf node.\n\nTo find the maximum/larges number of nodes a binary tree can have we use this formula: 2^(height or n) - 1 max nodes possible at each tree height.\n\n![](/assets/images/2022-01-02-23-40-55.png)\n\nA given binary tree can be a full or complete binary tree. When we say a full binary tree we mean that each node has either exactly zero or two children. Since every node has to point to at least two nodes after the root node, a full binary tree cannot have an even number of nodes.\n\nWhereas a complete binary tree is completely filled(except the last level sometimes) and is made so that all given sub nodes are as far left as possible.\n\n![](/assets/images/2022-01-02-23-41-09.png)\n","n":0.046}}},{"i":26,"$":{"0":{"v":"Traverse","n":1},"1":{"v":"\nWhen you navigate through a tree and find all the data it contains you call that a traversal, as it traverses the whole binary tree.\n\n![](/assets/images/2022-01-02-23-51-27.png)\n\nThe first method of traversal is called is pre-order traversal\n\nFor this you can use a simple recursion algorithm to traverse the tree and print all the letters contained by the nodes.\n\n```javascript\nfunction BSTpre(tree) {\n  if (tree) {\n    print(tree.value);\n    BSTpre(tree.left);\n    BSTpre(tree.right);\n  }\n}\n```\n\nThe second method is called in-order traversal where you go around the tree counterclockwise. In this case the letter is only printed after it has traversed down the left branch. Using this method in a sorted binary tree, you are able to print all numbers in the correct order.\n\n```javascript\nfunction BSTinOrder(tree) {\n  if (tree) {\n    BSTinOrder(tree.left);\n    print(tree.value);\n    BSTinOrder(tree.right);\n  }\n}\n```\n\nThe last method is called post-order traversal similar to in-order traversal you go through the tree counterclockwise but you print the value of each node as you pass the right side instead of the left like in-order. Each value is printed the last time it is reached recursively as it moves left and then right to print the data last.\n\n```javascript\nfunction BSTpost(tree) {\n  if (tree) {\n    BSTpost(tree.left);\n    BSTpost(tree.right);\n    print(tree.value);\n  }\n}\n```\n\nThe method you use to traverse the tree depends on what you are trying to do.\n\n## Depth First Search\n\n```mermaid\ngraph TD;\n    a-->b;\n    a-->c;\n    c-->f;\n    b-->d;\n    b-->e;\n```\n\nDFS is an algorithm where you go down a branch until the leaf is reached and process and proceed to another branch and so on. DFS usually make use of a stack to track all the visited nodes. For depth first search we can utilize any of the methods we outlined above. The basic implementation of a DFS on a binary tree is the pre-order traversal.\n\nSo for the given binary tree above for our DFS if we utilized a pre-order traversal we would come up with the result shown below:\n\npre-order : ['a', 'b', 'd', 'e', 'c', 'f' ]\n\nBelow we can see similar implementation of of a depth first search on a tree, recursively and iteratively using a stack.\n\n```javascript\n//Recursive\n//under the hood js will use a stack structure to keep track of all recursive calls.\nfunction depthFirstTree(tree) {\n  if (tree === null) return [];\n  const leftValue = depthFirstTree(tree.left); //[b,d,e]\n  const rightValue = depthFirstTree(tree.right); //[c,f]\n  return [tree, ...leftValue, ...rightValue]; //spread operator\n}\n//DFS: ['a', 'b', 'd', 'e', 'c', 'f' ]\n//Iterative\nfunction depthFirstTree(tree) {\n  if (tree === null) return [];\n  let result = [];\n  const stack = [tree];\n  while (stack.length > 0) {\n    const current = stack.pop();\n    result.push(current.value);\n    if (current.left) stack.push(current.left);\n    if (current.right) stack.push(current.right);\n  }\n  return result;\n  //DFS: ['a', 'b', 'd', 'e', 'c', 'f' ]\n}\n```\n\n## Breadth First Search\n\n```mermaid\ngraph TD;\n    a-->b;\n    a-->c;\n    c-->f;\n    b-->d;\n    b-->e;\n```\n\nBFS is an algorithm that is counterpart to DFS, where DFS make use of a stack BFS makes use of a queue for its data array. Thus elements are visited in a first in first out method(FIFO). This can also be called level order traversal as all nodes on a given level are visited before going to the next level.\n\nBFS is usually used in maps for finding the shortest route (google maps) or finding how many friend links/ relations you are from someone (facebook or linkedin). BFS is used often when you are looking for the \"nearest\" solution.\n\nBelow we can see an implementation of a breadth-first search on a tree. Here as it's a breadth First search we have to implement it iteratively using a queue.\n\n```javascript\nfunction breadthFirstTree(tree) {\n  if (tree === null) return [];\n  const queue = [tree];\n  const result = [];\n  while (queue.length > 0) {\n    let current = queue.shift();\n    result.push(current.val);\n    if (current.left) queue.push(current.left);\n    if (current.right) queue.push(current.right);\n  }\n  return result;\n}\n//BFS ['a', 'b', 'c', 'd', 'e', 'f']\n```\n\nSo in total the traversal algorithm are as follows:\n\n- BFS\n- pre-order traversal\n- in-order traversal\n- post-order traversal\n","n":0.041}}},{"i":27,"$":{"0":{"v":"Search Trees","n":0.707},"1":{"v":"\nBinary trees are used to store data so we want to have them be structured and sorted so that they are easy to search as previously stated. This is where Binary Search Trees(BST) come in, BST is a Binary tree where each node on the left(left subtree) has to contain smaller values and all nodes on the right(subtree) have to contain large values.\n\nBSTs do not have any duplicate elements in the tree.\n\n![](/assets/images/2022-01-02-23-49-00.png)\n\nFollowing the given image above and using the rules stated above we can state that for example to insert 9 into the tree we can only do so as the left child of 10. 9 is greater than 8 so would have to go right side, we can't put it as a child of 13 as its a child of 14 which is greater than 10 thus all children of 14 have to be greater than 10.\n\nSo as an example for our BST above if we chose to implement the 4 traversal methods previously mentioned we would have the results shown below:\n\n- BFS : [8,3,10,1,6,14,4,7,13]\n- pre-order traversal : [8,3,1,6,4,7,10,14,13]\n- in-order traversal: [1,3,4,6,7,8,10,13,14]\n- post-order traversal : [1,4,7,6,3,13,14,10,8]\n\n---\n\nWhen working with BST if we want the best performance BST should be well balanced, so that both Branches are filled with no gaps. leaving a complete branch as previously stated.\n\nWe know that for any given BST that is complete/balanced, the time taken to find a given node is proportional to the node depth equal to approximately log2(n). therefore the runtime of this search will be of O(log n).\n\nFor an unbalanced tree the performance of the search is not as optimal as a balanced tree thus its runtime will be of O(n). Thus we can say that for a given tree its runtime will be between O(log n) and O(n) for best and worst case scenario. As can be seen in the picture below for an unbalanced tree we might have to traverse through all nodes present hence the run time of O(n).\n\n![](/assets/images/2022-01-02-23-49-55.png)\n![](/assets/images/2022-01-02-23-50-55.png)\n\nOne thing to make note of is that a balanced tree might not always be the best. For example if you're trying to see which has the best worst case for searches between a balanced tree with depth/height of 20 and unbalanced with 18. The best one in this case would be unbalanced with 18 as in the worst case only 19 comparisons will take place compared to the 21 required for the balanced tree.\n\nBut if you are searching for a particular value where both have the same number of nodes the best one would be an unbalanced tree.\n\nWhen creating a BST to maintain the propoerties of BST each node inserted has only one correct position it could go in assuming each value inserted is unique. Thus the order in which numbers are added into the BST does affect the performance of the BST. Adding a sorted data into BST has the worst runtime of O(n).\n","n":0.045}}},{"i":28,"$":{"0":{"v":"Balancing","n":1},"1":{"v":"\nWe know that a BST needs to be well balanced to give optimal performance and results, but there are different ways of balancing trees. Here\n\nOne way of balancing BSTs is a tree rotation, tree rotation changes the structure of the tree but does not affect the structure of the tree. Rotations are usually used to balance two branches of different depths.\n\nIn a rotation a node is shifted up while another node is shifted down. Other nodes may need to also be shifted to maintain the integrity of the binary tree. These rotations can change the height of the tree by moving large subtrees. As it can be seen below in both rotations the order of the nodes has not changed but the levels of the nodes has shifted.\n\nWe can also see that due to the rotation that the children of the nodes being rotated are also shifted but still stay the children of the nodes. Only thing changing the level/depth of these nodes. Thus we can see that this is a great way to balance trees as it does not matter if the node in rotation has parents. Hence we can use rotations at any level/depth within the tree.\n\n![](/assets/images/2022-01-02-23-41-37.png){max-width: 300px}\n\nIn the example below you can see that we can use rotations to make a tree that is unbalanced balanced by applying rotations.\n\n![](/assets/images/2022-01-02-23-41-52.png)\n\nFor the tree above after rotation has been applied the tree has been balanced. But balancing trees continually is not optimal hence **AVL** is applied.\n\n---\n\n## AVL\n\nAVL tree are a self balancing BST tree that applies rotation automatically as it's always balanced. Thus it is a much faster operation than most BSTs. When inserting a node the branch is inspected for balancing and the appropriate rotation is applied to make the tree balanced.\n\nAVL looks at pattern of the branches in a tree where insertion of a node is occurring and looks for four patterns.\n\n- Left-Left\n- Left-Right\n- Right-Left\n- Right-Right\n\nIt performs these rotations after insertion of a new node, applying rotation to the node one or two levels above it or both.\n\nLeft-Left(LL): In this operation a right rotation is performed on the node above the inserted node. As shown in the picture below the inserted node is moved up and the node two levels up is moved down.\n\n![](/assets/images/2022-01-02-23-43-22.png)\n\nLeft-Right(LR): This is a multi step process where a left rotation on the node above the inserted node is applied moving the above node down and the inserted node up. After which a right rotation is applied on the node that was two levels above the inserted node, moving the inserted node up and the top node down.\n\n![](/assets/images/2022-01-02-23-44-15.png)\n\nRight-Left(RL): In this operation a right rotation is performed on the node above the inserted node moving the inserted node up and the above node down. After that a left rotation is performed on the node two that was above two levels the inserted node. moving the above node below the inserted node.\n\n![](/assets/images/2022-01-02-23-44-38.png)\n\nRight-Right(RR): In this operation a left rotation is performed on the node above the inserted node, moving it up and the node two levels up down.\n\n![](/assets/images/2022-01-02-23-44-52.png)\n\nAs can be seen thus far balancing is really easy with AVL trees, But the downsides of AVL is insertion and deletions. In these cases they can be operationally heavy as several rotations per each operation can be required.\n\n---\n\n## RED-Black\n\nThere is another self balancing tree similar to AVL, the **red-black tree**. This algorithm does not have strict balancing requirements like AVL so its look up is slower than AVL, but its insertion and deletion operation are much faster due to requiring less rotations per operation.\n\n![](/assets/images/2022-01-02-23-46-48.png)\n\nHow these trees work is that each node in the tree is either red or black, where new inserted nodes are always marked red. After insertion the color of the surrounding nodes is assessed and the nodes are rotated or repainted to achieve the conditions below:\n\n- All red leaves must have only child nodes colored black.\n- the root of the tree must always be black\n- No matter where you are in the tree, every path to a leave/leaf node must go through the same number of black nodes.\n\nThe tree resulting from this algorithm is not perfectly balanced as AVL trees but its runtime operation for lookup is still O(log n) and for insertion and deletion.\n\nThis is due to the tree having a maximum total height of 2 log (n+1)\n\n#### Insertion\n\nWhen a new node is inserted into a red-black tree, the algorithm searches through the tree to find the correct spot based on the value and places the node(similar to BST) then paints the node red. After that is complete it assesses the surrounding nodes and performs either of these 4 actions:\n\n1. In the first case the new nodes parent is black, the red-black properties are upheld and nothing is done.\n\n2. The second case the new nodes parent and its siblings are painted red. Here you would switch the color of the parent and parent sibling node to black and switch the grandparent to the node to red.\n\n3. Here the new nodes parent is red and its sibling is black, and the new nodes value is between the parent and grandparent.\n\n   - If the new node is greater than the parent, the parent is rotated left, where as if the node is less than the parent the parent is rotated right.\n\n4. The last case is where the new nodes parent is red and the parent sibling is black. The parent node should be between the value of the new node and the grandparent.\n   - If the new node value is less than the parent, the grandparent is rotated right and the colors of the parent and grandparent are swapped.\n   - if the new node value is greater than the parent, the grandparent is rotated left and the colors are swapped.\n\nFor the tree below if we were to insert 7, based on rules of BST it will be inserted in the right branch of 6. After which we would follow the cases outlined above, The grandparent (1) is rotated left and the colors of grandparent and parent nodes and it's children are switched.\n\n![](/assets/images/2022-01-02-23-47-14.png)\n\nAnother example:\n![](/assets/images/2022-01-02-23-47-35.png)\n\n---\n\nIn general AVL and red-black trees will have a faster runtime for lookup compared to BST and binary tree.\n\nThus we can say that if a runtime of a algorithm for lookup is closer to O(N) we know that it will not be AVL or red-black trees as their lookup time is guaranteed to be in O(log n).\n\nWhen looking at creating a tree and if we're choosing between AVL and red-black, we look and see if we will be doing lots of insertion and deletion operations if so the best bet is to go with red-black trees. But if the tree is static or unchanging the best tree to use would be AVL.\n","n":0.03}}},{"i":29,"$":{"0":{"v":"Arrays","n":1},"1":{"v":"\nArrays are the most used data structures, and is a fundemental data structure.\n\nA static array is a fixed length container which contains n elements that is indexable from the range 0 to n-1. Static Arrays are created as continuous chunks of memory, each element in the static array is sequential addressed.\n\nStatic arrays are used for storing and accessing sequential data, temporarily store objects, used as buffers in IO, used in dynamic programming to cache subproblem answers and more.\n\nCompared to static arrays, dynamic array can grow and shrink in size. Generally a dynamic array can be created using a static array, we can do so by checking the size of our current array and elements being inserted. Then based on size of our element and array we can double our static array if we find we can't fit our element into our static array. Thus we can keep continuing resizing our array as we add elements to our static array.\n\nIn an Array when we access an array due to it being indexable the time is constant at O(1), where as if we're searching for an element it'll be a linear time of O(n) similar to insertion and deletion.\n\nBelow are some methods to traverse an array and sort an array.\n\nJavascript\n\n```javascript\nconst nums = [];\nconst nums = new Array();\nconst nums = new Array(5).fill(0);\nfor (const num of nums) {\n  console.log(num);\n}\nfor (let i = 0; i < nums.length; i++) {\n  console.log(nums[i]);\n}\n//sort\nnums.sort((a, b) => a - b);\n```\n\n---\n\nJava\n\n```java\nString [] name = new String [];\n\n\nfor (String name : names) {\n  System.out.println(name);\n}\nfor (int i = 0;i<names.length;i++) {\n  System.out.println(name);\n}\nArrays.stream(names).forEach(System.out::println);\nSystem.out.println(Arrays.toString(names));\nSystem.out.println(Arrays.deepToString(names));\n//sort\nArrays.sort()\n```\n","n":0.062}}},{"i":30,"$":{"0":{"v":"Heaps","n":1}}},{"i":31,"$":{"0":{"v":"Hash Table","n":0.707}}},{"i":32,"$":{"0":{"v":"Graphs","n":1},"1":{"v":"\n<img src='https://g.gravizo.com/svg?\n digraph G {\n   w -> n;\n   w -> n;\n   w -> s;\n   w -> s;\n   w -> e;\n   e -> n;\n   e -> s;\n }\n'/>\n\nA structure like this is called a graph, and the points W,E,S,N would be called vertices and the lines connecting them can be represented as edges.\n\nA lot of things can be implemented as a graph such as a road network where intersections can be vertices and the road as edges. Graphs are how most GPS devices work.\n\nIf you travel through all the edges once, you'd call the eulerian path, eulerian path is one that uses every edge exactly once and the number of vertices passed does not matter. The eulerian path starts or ends at the vertex, one of the ways to recognize the start and end of a path is by looking at vertices which has an odd number of edges. That means it is one of the two ends of the eulerian path. Thus by that logic we can say that if a graph has more than two vertices with odd edges, there is no eulerian path.\n\nAnother image example of graphs can be found below. Which shows how graphs can either be directed or undirected graph. The only difference between both graphs is one has directionality, So for example in the directed graph if you are 1 you can only travel towards 2, as you have to observe and follow the directionality of the graph. where as in the undirected graph we can travel to 0,2,and 4 from 1.\n\n![](/assets/images/2022-01-28-07-45-28.png)\n\nOne useful terminology is considering the connected edges of a given node as neighbor nodes. Though this has to follow the directionality of the graph. So if we look at our example graph above. We can say that for the node 1, it's neighbor is 2, for node 0 it's neighbor is 2 and 1.\n\nGraphs can also be created to solve and represent puzzle games\nSuch as the farmers problem where the farmer has to get a wolf a goat and cabbage across the river, but the boat they have has only room for one more item.\n\n![](/assets/images/2022-01-28-07-45-52.png)\n\nThis can be represented by a graph as such where each possible state is mapped out including the ones that break the rules of the game. Where the moves made are edges and the arrangement of the items and farmer are vertices.\n\nAs there is 4 characters and three locations we can say that there are 3^4 possible states including invalid moves for the problem:\n\n![](/assets/images/2022-01-28-07-46-07.png)\n","n":0.049}}},{"i":33,"$":{"0":{"v":"Traverse","n":1},"1":{"v":"\nWhen trying to implement a graph in our preferred language of choice, we can represent graphs in an adjacency list (hashmap data structure), this can be an object for javascript, and unordered map for java.\n\n```mermaid\ngraph LR;\n    a-->b;\n    a-->c;\n    b-->d;\n    c-->e;\n    e-->b;\n    f-->d;\n```\n\n```javascript\nconst graph = {\n  a: [b, c],\n  b: [d],\n  c: [e],\n  d: [],\n  e: [b],\n  f: [d],\n};\n```\n\n### Depth First Traversal\n\nFor depth first traversal, given a source node, the algorithm travels through the graph and explores until it reaches the end of the given path before backtracking.\n\nSo in our given example graph, if our source node is A, one path we could take is: [A,C,E,B,D] if we had chosen b instead of C our path would look like [A,B,D].\n\nTo Build a depth first traversal algorithm we can use a data structure we learned previously a stack to implement this. And we know that Stack works on the LIFO, so we can first visualize how this will work on our graph.\n\n![](/assets/images/2022-01-28-08-36-17.png)\n\nAs seen above if we initialize our stack with the node A, we can then pop node A of our stack and push into the stack the neighbors of A. Then we can go through the whole graph by popping an element from the stack and pushing the neighbors of the current node until the stack is empty. At that point we have traversed through all nodes in the graph, using the depth-first traversal method.\n\nNow we can implement Depth First Traversal in our code in two ways, iteratively or recursively.\n\nFor our first method we will choose to use the recursive method which is simpler than the iterative method.\n\n```javascript\nconst depthFirstSearch = (graph, source) => {\n  console.log(source);\n  for (const neighbor of graph[source]) {\n    depthFirstSearch(graph, neighbor);\n  }\n};\n```\n\nand our iterative method will look something like this:\n\n```javascript\nconst depthFirstSearch = (graph, source) => {\n  const stack = [source];\n\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    console.log(currentNode);\n    for (const neighbor of graph[currentNode]) {\n      stack.push(neighbor);\n    }\n  }\n};\n```\n\n### Breadth First Traversal\n\nFor Breadth first traversal, given a source node, the algorithm travels through the graph and explores all given nodes at the current depth it's at, before traversing to the next depth of the graph until it reaches the end.\n\nSo in our given example graph at the top, if our source node is A, a path we could take would look something like this: [A,B,C,D,E,F].\n\nTo Build a Breadth first traversal algorithm we can use a data structure we learned previously a Queue to implement this. And we know that Queue works on the FIFO method, so we can first visualize how this will work on our graph.\n\n![](/assets/images/2022-01-28-09-01-03.png)\n\nAs seen above if we initialize our Queue with the node A, we can then shift node A of our Queue and push into the Queue the neighbors of A. Then we can go through the whole graph by shifting an element from the Queue and pushing the neighbors of the current node until the Queue is empty. At that point we have traversed through all nodes in the graph, using the Breadth-first traversal method.\n\nDifferent from our Depth-first traversal, breadth-first traversal can only be performed iteratively.\n\n```javascript\nconst breadthFirstSearch = (graph, source) => {\n  const Queue = [source];\n\n  while (Queue.length > 0) {\n    const currentNode = Queue.shift();\n    console.log(currentNode);\n    for (const neighbor of graph[currentNode]) {\n      Queue.push(neighbor);\n    }\n  }\n};\n```\n\n### Related Topics\n\n- [[data-structures.stacks]]\n- [[data-structures.queues]]\n","n":0.043}}},{"i":34,"$":{"0":{"v":"Complexity","n":1}}},{"i":35,"$":{"0":{"v":"Cloud","n":1},"1":{"v":"\n- [ ] AWS\n- [ ] Azure\n- [ ] Firebase\n- [ ] Netlify\n- [ ] Surge\n- [ ] SAAS\n- [ ] Heroku\n","n":0.213}}},{"i":36,"$":{"0":{"v":"Problems","n":1},"1":{"v":"\nCollection of Data Structure and Algorithm Problems, with explanation and solution in both java and javascript with links to concepts that pertain to the problem.\n\nMost questions present have an obvious pattern, can be broken down to it's basic pattern. The first step is always brute force but we can follow these patterns into optimizing our solutions. These patterns usually lead you to the most optimal solution time complexity wise.\n\n## Patterns\n\n1. Sliding Window\n2. Two Pointers / Iterators\n3. Fast and Slow Pointers\n4. Merge Intervals\n5. Cyclic Sort\n6. In-Place Reversal of Linked Lists\n7. Tree BFS/DFS\n8. Two Heaps\n9. Subsets\n10. Binary Search\n11. Top K Elements\n12. K-Way Merge\n13. Topological Sort\n\n- If you have a problem with sorted arrays/linked lists and need to find a set of elements: **Two Pointers**.\n- If you have a problem with arrays/linked list and and need to find /calculate something among subarrays/sublists: **Sliding Window**.\n- if you have a problem with cyclic arrays/linked lists: **Fast & Slow Pointers**.\n- If you have a problem which deals with intervals (overlapping/merging): **Merge Intervals**.\n- If you have a problem with arrays and a given range and asked to find missing elements etc..: **Cyclic Sort**.\n- If you have a problem with linked list and asked to reverse nodes: **In-Place Reversal of Linked Lists**.\n- If you have a problem with traversing a tree like structure in a level/depth order: **Breadth First Search**.\n- If you have a problem requiring exploring depth of a path, etc.. : **Depth First Search**.\n- If you have a problem where it can be divided into two parts(min and max): **Two Heaps**.\n- If you have a problem involving permutations/combinations of elements: **Subsets(efficient BFS)**.\n- If you have a problem with sorted array/linkedlist/matrix and need to find a specific element: **Binary Search**.\n- If you have a problem involving solving same problems repeatedly(dynamic): **Dynamic Programming(Knapsack)**.\n- If you have a problem involving bits or finding missing numbers: **Bitwise XOR**.\n- If you have a problem involving finding a linear order of elements that depend on each other: **Topological Sort**.\n- if you have a problem with sorted list of arrays: **K-way Merge**.\n- if you have a problem involving finding the top/smallest/frequent k elements in a set: **Top K Elements**.\n\n## Other Strategies\n\n- Array and String We can use two pointers, HashMap and HashSet.\n\n- If problem involves something where an array is sorted, we can use either a binary search or two pointer method.\n\n- If it involves a linked list we can use a two pointer approach\n\n- If it involves a Tree or a Graph we can use DFS, and BFS\n\n- if problem asks for (Frequency/counter/duplicates/common string) think about using maps\n\n- if problem asks for (Top/ Least K Items) think about using Heap\n\n- if problem asks for (Maximum/minimum/subarray/subs etc..) think about using Dynamic Programming\n\n- if problem asks for (Permutation/Subsets) think about using Back Tracking\n\n- if problem asks for (Recursion is prohibited) think about using Stack\n\n- if problem asks for (common String) think about using Map or Trie\n","n":0.046}}},{"i":37,"$":{"0":{"v":"Graphs","n":1},"1":{"v":"\n## Graph Problems\n\n- [ ] 1. Depth-First Search\n- [ ] 2. Single Cycle Check\n- [ ] 3. Breadth-First Search\n- [ ] 4. River Sizes\n- [ ] 5. Youngest Common Ancestor\n- [ ] 6. Remove Islands\n- [ ] 7. Cycle In Graph\n- [ ] 8. Minimum Passes of Matrix\n- [ ] 9. Boggle Board\n- [ ] 10. Rectangle Mania\n- [ ] 11. Detect Arbitrage\n- [ ] 12. Two-Edge Connected Graphs\n- [ ] 13. Airport Connections\n","n":0.116}}},{"i":38,"$":{"0":{"v":"Shortest Path","n":0.707},"1":{"v":"\n## Question\n\ngiven an edge list and a start/end node return the shortest path in the graph.\n\n#### input:\n\n```javascript\nconst edges = [\n  [1, 2],\n  [2, 3],\n  [5, 3],\n  [5, 4],\n  [1, 4],\n];\n```\n\n#### Output:\n\npath-length=2\n\n## Solution\n\nFor this problem, it first helps to visualize the graph like below.\n\n```mermaid\ngraph TD;\n    1---3;\n    3---6;\n    6---4;\n    4---9;\n    9---1;\n```\n\nSo if we have our start node be 6 and our end node be 9, we can then count the number of edges between the start and end, if we go through 3 we find that the number of edges is 3, and if we go through 4 our edge length is 2. comparing both we find that our shortest path is 2 and return that.\n\nSo we can implement this simply and fast through a breadth-first traversal. Because if we choose a depth first traversal we would be forced to look through one direction until the end. Which would be inefficient in worst case(aka chosen the wrong direction) if we had a large graph.\n\nSo if we go through breadth-first traversal we will know that the first time we encounter the node will be the shortest path to the given end node.\n\nWhen we create our queue for our breadth-first traversal other keeping track our node we would also track the distance from the start node with it.\n\n#### Javascript\n\n```javascript\nconst shortPath = (edges, start, end) => {\n  const visited = new set();\n  const graph = createGraph(edges);\n  return helper(graph, start, end, visited);\n};\n\nconst createGraph = (edges) => {\n  const graphs = {};\n  for (const items of edges) {\n    const [a, b] = items;\n    if (!(a in graphs)) graphs[a] = [];\n    if (!(b in graphs)) graphs[b] = [];\n    graphs[a].push(b);\n    graphs[b].push(a);\n  }\n  return graphs;\n};\nconst helper = (graph, start, end, visited) => {\n  const queue = [[start, 0]];\n\n  while (queue.length > 0) {\n    const [current, distance] = queue.shift();\n    if (neighbor === end) return distance;\n    for (const neighbor of graph[current]) {\n      if (visited.has(neighbor)) continue;\n      visited.add(neighbor);\n      queue.push([neighbor, distance++]);\n    }\n  }\n  return -1;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.Graphs]]\n- [[data-structures.Graphs.traverse]]\n\n## Patterns\n\n- BFS\n- Set/Map\n","n":0.055}}},{"i":39,"$":{"0":{"v":"Minimum Island","n":0.707},"1":{"v":"\n## Question\n\nGiven a grid containing 1s and 0s, where 0 represents water and 1 represents land. return the smallest island within the grid.\n\nThere is at least one island in the grid.\n\n#### input:\n\n```javascript\ngrid = [\n  [\"1\", \"1\", \"1\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"0\", \"0\"],\n];\n```\n\n#### Output:\n\nminSize = num;\n\n## Solution\n\nHere we follow the same pattern as the island count, but instead of returning boolean values we return the size of the given island.\n\n#### Javascript\n\n```javascript\nvar minIsland = function (grid) {\n  const visited = new Set();\n  var min = 0;\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      const size = helper(grid, row, col, visited);\n      if (size > 0) min = Math.min(size, min);\n    }\n  }\n\n  return min;\n};\n\nvar helper = function (grid, row, col, visited) {\n  const rowBound = 0 <= row && row < grid.length;\n  const colBound = 0 <= col && col < grid[0].length;\n  if (!rowBound || !colBound) return 0;\n\n  if (grid[row][col] === \"0\") return 0;\n  const position = row + \",\" + col;\n  if (visited.has(position)) return 0;\n  visited.add(position);\n  let currentSize = 1;\n  currentSize += helper(grid, row - 1, col, visited);\n  currentSize += helper(grid, row + 1, col, visited);\n  currentSize += helper(grid, row, col - 1, visited);\n  currentSize += helper(grid, row, col + 1, visited);\n  return currentSize;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.Graphs]]\n- [[data-structures.Graphs.traverse]]\n\n## Patterns\n\n- DFS\n- Set/Map\n","n":0.066}}},{"i":40,"$":{"0":{"v":"Largest Component","n":0.707},"1":{"v":"\n## Question\n\nGiven an adjacency list of an undirected graph, return the size of the largest component in the graph.\n\n#### input:\n\n```javascript\nconst largestComponent = {\n  0: [\"1\", \"2\", \"3\"],\n  1: [\"1\", \"2\", \"3\"],\n  3: [\"1\", \"2\"],\n  4: [\"1\", \"2\"],\n};\n```\n\n#### Output:\n\nsize\n\n## Solution\n\nTo solve the problem, we can follow the pattern of finding a path in an undirected graph. The only difference now is that we have to use a counter for which we can keep track of the size of the graph and compare to other components\n\nfor example in our example graph below we can see that our largest component would be size of 4.\n\n```mermaid\ngraph TD;\n    1---3;\n    4---2;\n    4---7;\n    4---9;\n    6\n\n```\n\n#### Javascript\n\n```javascript\nconst largestComp = (graph) => {\n  const visited = new set();\n  const largest = 0;\n  for (const node of graph) {\n    const current = helper(graph, node, visited);\n    if (current > largest) largest = current;\n  }\n  return largest;\n};\n\nconst helper = (graph, node, visited) => {\n  if (visited.has(node)) return 0;\n  visited.add(node);\n  let size = 0;\n  for (const neighbor of graph[node]) {\n    size += helper(graph, neighbor, visited);\n  }\n  return size;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.Graphs]]\n- [[data-structures.Graphs.traverse]]\n\n## Patterns\n\n- DFS\n- Set/Map\n","n":0.074}}},{"i":41,"$":{"0":{"v":"Island Count","n":0.707},"1":{"v":"\n## Question\n\nGiven a grid of 1s and 0s. where 0 represents water and 1 represents land. You should return the number of islands on the given grid.\n\ndefinition of an island is a land vertically or horizontally connected.\n\n#### input:\n\n```javascript\ngrid = [\n  [\"1\", \"1\", \"1\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"0\", \"0\"],\n];\n```\n\n#### Output:\n\nOutput: 1\n\n## Solution\n\nThis is different from the format we've usually seen for our graphs, instead of an adjacency list we're given now a grid instead.\n\nTo solve this question we have two choices either depth-first or breadth-first. So we can solve this by iterating over the grid to move to each node, and at each point calling our depth first function. to iterate through and find an island at that particular point. If we find an island we return and increment our island counter.\n\nWhen we go through our islands, we will still be using the same principles as before, making use of a set to keep track of all points visited by our function.\n\nWe first need a way to iterate through our given grid, and we can do that simply using two for loops, after that we will be calling our depth-first function at each point on the grid.\n\nWithin our depth-first function we set up the bounds of the given grid, so that when we run this function recursively, we are checking against the bounds we set, to see if the given point is valid. if it's not valid we can simply return false, same if the point we're checking is water or it has been visited before.\n\n#### Javascript\n\n```javascript\nvar numIslands = function (grid) {\n  const visited = new Set();\n  var count = 0;\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (helper(grid, row, col, visited) === true) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n};\n\nconst helper = (grid, row, col, visited) => {\n  const rowBound = 0 <= row && row < grid.length;\n  const colBound = 0 <= col && col < grid[0].length;\n  if (!rowBound || !colBound) return false;\n\n  if (grid[row][col] === \"0\") return false;\n\n  const position = row + \",\" + col;\n  if (visited.has(position)) return false;\n  visited.add(position);\n\n  helper(grid, row - 1, col, visited);\n  helper(grid, row + 1, col, visited);\n  helper(grid, row, col - 1, visited);\n  helper(grid, row, col + 1, visited);\n\n  return true;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.Graphs]]\n- [[data-structures.Graphs.traverse]]\n\n## Patterns\n\n- DFS\n- Set/Map\n","n":0.05}}},{"i":42,"$":{"0":{"v":"Has Path","n":0.707},"1":{"v":"\n## Question\n\nGiven a graph and a destination node on the graph return true, if there's a path from the source node to the destination node.\n\n#### input:\n\nsource: 1\n\nDestination: 4\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    2-->3;\n    2-->4;\n    3-->5;\n    6-->2;\n```\n\n#### Output:\n\nTRUE\n\n## Solution\n\nWe can solve this either using depth-first search or using breadth-first search. For our solution here we will use depth-first search.\n\nWhen looking at the time complexity of the algorithm we can say that _**n**_ would be the number of nodes and _**e**_ the number of edges. Thus we can state in the worse case our time complexity would be O(n+e), and our space complexity would be O(n).\n\n#### Javascript\n\n```javascript\nconst depthFirstSearch = (graph, source, destination) => {\n  if (source === destination) {\n    return true;\n  }\n  for (const neighbor of graph[source]) {\n    if (depthFirstSearch(graph, neighbor, destination) === true) {\n      return true;\n    }\n  }\n  return false;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.Graphs]]\n- [[data-structures.Graphs.traverse]]\n\n## Patterns\n\n- DFS\n","n":0.083}}},{"i":43,"$":{"0":{"v":"Has Path Undirected","n":0.577},"1":{"v":"\n## Question\n\ngiven an array of edges for an undirected graph a source node and a target node, return true if the source node has a path to the target node.\n\n#### input:\n\n```javascript\nconst edges = [\n  [1, 4],\n  [2, 1],\n  [3, 2],\n  [5, 2],\n  [6, 7],\n];\n```\n\n#### Output:\n\nTRUE\n\n## Solution\n\nAs this is a graph we can use depth-first search to find the path, the only thing that's different this time is that we have an undirected graph. It can help to visualize how the graph might look, as the image shown below. But in order to solve the problem using the previously defined methods. We need to convert from the array list of edges to an adjacency list.\n\n```mermaid\ngraph TD;\n    1----4;\n    1----2;\n    2----3;\n    2----5;\n    4----2;\n    6----7;\n\n\n```\n\nAfter we convert the edges we have to an adjacency list we can go forward with trying to find a path to the destination.\n\nIn this case we need to change how we find the path slightly by checking if the node we're on currently has been visited. We do this so we can avoid an infinite loop.\nAs this graph contains a trivial cycle and a cycle of length 3.\n\n#### Javascript\n\n```javascript\nconst hasPath = (edges, start, destination) => {\n  const graph = createGraph(edges);\n  return depthFirstTraversal(graph, start, destination, new set());\n};\n\nconst createGraph = (edges) => {\n  const graphs = {};\n  for (const items of edges) {\n    const [a, b] = items;\n    if (!(a in graphs)) graphs[a] = [];\n    if (!(b in graphs)) graphs[b] = [];\n    graphs[a].push(b);\n    graphs[b].push(a);\n  }\n  return graphs;\n};\n\nconst depthFirstTraversal = (graph, start, destination, visited) => {\n  if (start === destination) return true;\n  if (visited.has(start)) return false;\n  visited.add(start);\n  for (const neighbor of graph[start]) {\n    if (\n      (depthFirstTraversal = (graph, neighbor, destination, visited) === true)\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.Graphs]]\n- [[data-structures.Graphs.traverse]]\n\n## Patterns\n\n- DFS\n- Set/Map\n","n":0.058}}},{"i":44,"$":{"0":{"v":"Connected Components Count","n":0.577},"1":{"v":"\n## Question\n\nGiven an unconnected graph, in the form of an adjacency list, your function should return the number of connected components within the graph.\n\n#### input:\n\n```javascript\nconst list = {\n  0: [8, 1, 5],\n  1: [0],\n  5: [0, 8],\n  8: [0, 5],\n  2: [3, 4],\n  3: [2, 4],\n  4: [3, 2],\n};\n```\n\n#### Output:\n\ncount = 2\n\n## Solution\n\nAs the graph given is an undirected graph, when we implement our depth-first search algorithm, we need to check that we are not running into a cycle. So this section stays the same as previous problems.\n\nThe difference now is that we need to go through all the nodes in our graph iteratively to check if we have a connected component.\n\nFor example in our graph below, if we went through each node and called our depth function we can find that starting from one we will have searched all paths, and thus have visited nodes 3,5,and 6 and saved in our set. then we move to our next node 2 and do the same our connected component counter is now at 2.\n\nWhen we move to node 3 we will see that we have already visited this node so we skip to the next node, and so on until we reach 10 which we have not visited. After that our count goes 3 and we have finished looping iteratively through our graph nodes.\n\n```mermaid\ngraph TD;\n    1----3;\n    1----5;\n    1----6;\n    2----4;\n    10;\n\n```\n\n#### Javascript\n\n```javascript\nconst connectedComponents = (grpah) => {\n  const visited = new set();\n  const count = 0;\n  for (const node in graph) {\n    if (visited.has(node)) continue;\n    depthFirstTraverse(graph, node, visited);\n    count++;\n  }\n  return count;\n};\n\nconst depthFirstTraverse = (graph, source, visited) => {\n  if (visited.has(source)) return false;\n  visited.add(source);\n\n  for (const neighbor of graph[source]) {\n    if (depthFirstTraverse(graph, node, visited) === true) {\n      return true;\n    }\n  }\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.Graphs]]\n- [[data-structures.Graphs.traverse]]\n\n## Patterns\n\n- DFS\n- Set/Map\n","n":0.058}}},{"i":45,"$":{"0":{"v":"Binary Tree","n":0.707},"1":{"v":"\n## Binary Tree Problems To Do\n\n- [ ] Max Path Sum In Binary Tree\n- [ ] Find Nodes Distance K\n- [ ] Iterative In-Order Traversal\n- [ ] Flatten Binary Tree 10. Right Siblings Node Depths\n- [ ] Compare Leaf/leave Traversal\n","n":0.158}}},{"i":46,"$":{"0":{"v":"Tree Sum","n":0.707},"1":{"v":"\n## Question\n\nGiven a root of a tree, return the total sum of all values in the binary tree.\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    2-->6;\n    2-->7;\n    3-->4;\n    3-->8;\n```\n\n#### Output:\n\n## Solution\n\nwe can solve this by traversing through the graph and adding all our values as we go.\n\nThis can be done either through DFS (pre,post,in) or BFS.\n\n#### Javascript\n\n```javascript\nconst treeSum = (root) => {\n  if (root === null) return 0;\n  return root.val + treeSum(root.left) + treeSum(root.right);\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.recursion]]\n- [[data-structures.binary-trees]]\n- [[data-structures.binary-trees.traverse]]\n\n## Patterns\n\n- DFS\n","n":0.113}}},{"i":47,"$":{"0":{"v":"Tree Diameter","n":0.707},"1":{"v":"\n## Question\n\nGiven the root of a binary tree, return the length of the diameter of the tree.\n\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n\nThe length of a path between two nodes is represented by the number of edges between them.\n\nhttps://leetcode.com/problems/diameter-of-binary-tree/\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    3-->4;\n    3-->8;\n```\n\n#### Output:\n\n3\n\nlength of path (8-3-1-2)\n\n## Solution\n\n#### Javascript\n\n```javascript\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction binaryTreeDiameter(tree) {\n  // Write your code here.\n  let diameter = 0;\n\n  dfs(tree);\n\n  return diameter;\n\n  function dfs(node) {\n    if (!node) return 0;\n\n    const left = dfs(node.left);\n    const right = dfs(node.right);\n\n    // update diameter at every node\n    diameter = Math.max(diameter, left + right);\n\n    // update the largest number of edge so far\n    return 1 + Math.max(left, right);\n  }\n}\n```\n\n```javascript\nfunction binaryTreeDiameter(tree) {\n  // Write your code here.\n  let res = 0; //result --> diameter of tree\n\n  let solve = function (root) {\n    if (root === null) return 0;\n\n    let l = solve(root.left);\n    let r = solve(root.right);\n\n    let temp = 1 + Math.max(r, l);\n    let ans = l + r; // temporary answer\n    res = Math.max(ans, res); // final result(ans)\n    return temp;\n  };\n  solve(tree);\n  return res;\n}\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.recursion]]\n- [[data-structures.binary-trees]]\n- [[data-structures.binary-trees.traverse]]\n\n## Patterns\n\n- DFS\n","n":0.068}}},{"i":48,"$":{"0":{"v":"Node Depths","n":0.707},"1":{"v":"\n## Question\n\nGiven a binary tree return the sum of all the nodes depths\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    2-->6;\n    2-->7;\n    3-->4;\n    3-->8;\n    8-->10;\n```\n\n#### Output:\n\nsum = 13\n\n## Solution\n\n#### Javascript\n\n```javascript\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction nodeDepths(root) {\n  return calculateDepthSum(root, 0);\n}\nfunction calculateDepthSum(node, sum = 0) {\n  if (node === null) {\n    return 0;\n  }\n  return (\n    sum +\n    calculateDepthSum(node.left, sum + 1) +\n    calculateDepthSum(node.right, sum + 1)\n  );\n}\n```\n\n#### Java\n\n```java\nimport java.util.*;\n\nclass Program {\n\n  public static int nodeDepths(BinaryTree root) {\n    return calculateDepthSum( root, 0);\n  }\n\tpublic static int calculateDepthSum(BinaryTree node, int sum){\n\t\tif (node == null){return 0;}\n\t\treturn sum + calculateDepthSum(node.left, sum+1) +calculateDepthSum(node.right, sum+1);\n\t}\n\n  static class BinaryTree {\n    int value;\n    BinaryTree left;\n    BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n      left = null;\n      right = null;\n    }\n  }\n}\n\n```\n\n## Concepts\n\n- [[data-structures.binary-trees.traverse]]\n- [[data-structures.recursion]]\n\n## Patterns\n\n- DFS\n","n":0.084}}},{"i":49,"$":{"0":{"v":"Invert Binary Tree","n":0.577},"1":{"v":"\n## Question\n\nGiven a Binary Tree, invert it.\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    2-->6;\n    2-->7;\n    3-->4;\n    3-->8;\n    8-->10;\n```\n\n#### Output:\n\n```mermaid\ngraph TD;\n    1-->2;\n    1-->3;\n    2-->6;\n    2-->7;\n    3-->4;\n    3-->8;\n    8-->10;\n```\n\n## Solution\n\n#### Javascript\n\n```javascript\nfunction invertBinaryTree(tree) {\n  // Write your code here.\n  return helper(tree);\n}\nfunction helper(tree) {\n  if (!tree) {\n    return;\n  }\n  if (!tree.left && !tree.right) {\n    return;\n  }\n  let temp = tree.left;\n  tree.left = tree.right;\n  tree.right = temp;\n  helper(tree.left);\n  helper(tree.right);\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n```\n\n#### Java\n\n```java\nimport java.util.*;\n\nclass Program {\n  public static void invertBinaryTree(BinaryTree tree) {\n\t\thelper(tree);\n  }\n\tpublic static void helper (BinaryTree node){\n\t\tif (node == null){\n\t\t\treturn;\n\t\t}\n\t\tBinaryTree temp = node.left;\n\t\tnode.left = node.right;\n\t\tnode.right = temp;\n\t\thelper(node.left);\n\t\thelper(node.right);\n\t}\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n```\n\n## Concepts\n\n- [[data-structures.binary-trees.traverse]]\n- [[data-structures.recursion]]\n\n## Patterns\n\n- DFS\n","n":0.085}}},{"i":50,"$":{"0":{"v":"Height Balanced","n":0.707},"1":{"v":"\n## Question\n\nGiven a binary tree, determine if it is height-balanced.\n\nFor this problem, a height-balanced binary tree is defined as:\n\na binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n\nhttps://leetcode.com/problems/balanced-binary-tree/\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    3-->4;\n    3-->8;\n```\n\n#### Output:\n\ntrue\n\n## Solution\n\n#### Javascript\n\n```javascript\nfunction heightBalancedBinaryTree(tree) {\n  // Write your code here.\n  let dfs = function (node) {\n    if (!node) return 0;\n    let left = 1 + dfs(node.left);\n    let right = 1 + dfs(node.right);\n    if (Math.abs(left - right) > 1) return Infinity;\n    return Math.max(left, right);\n  };\n\n  return dfs(tree) == Infinity ? false : true;\n}\n//94ms\n```\n\n```javascript\nfunction heightBalancedBinaryTree(tree) {\n  // Write your code here.\n  return helper(tree) != -1;\n}\nfunction helper(node) {\n  if (!node) return 0;\n  let left = helper(node.left);\n  if (left == -1) return -1;\n  let right = helper(node.right);\n  if (right == -1) return -1;\n  if (Math.abs(left - right) > 1) return -1;\n  return Math.max(left, right) + 1;\n}\n//144ms\n```\n\n```javascript\nclass TreeInfo {\n  constructor(isBalanced, height) {\n    this.isBalanced = isBalanced;\n    this.height = height;\n  }\n}\n\nfunction heightBalancedBinaryTree(tree) {\n  const treeInfo = helper(tree);\n  return treeInfo.isBalanced;\n}\nfunction helper(node) {\n  if (!node) return new TreeInfo(true, -1);\n\n  let left = helper(node.left);\n  let right = helper(node.right);\n\n  const isBalanced =\n    left.isBalanced &&\n    right.isBalanced &&\n    Math.abs(left.height - right.height) <= 1;\n  const height = Math.max(left.height, right.height) + 1;\n  return new TreeInfo(isBalanced, height);\n}\n// 199 ms\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.binary-trees.traverse]]\n- [[data-structures.recursion]]\n\n## Patterns\n\n- DFS\n","n":0.068}}},{"i":51,"$":{"0":{"v":"Find Successor","n":0.707},"1":{"v":"\n## Question\n\nGiven a Binary Tree and a node contained in the tree, return the nodes successor.\n\nA nodes successor is the next node to be visited when traversing the tree using the in-order tree traversal algorithm. a node has no successor if its the last node to be visited in the in-order tree traversal.\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    3-->4;\n    3-->8;\n```\n\nnode = 4\n\n#### Output:\n\n8\n\n## Solution\n\nin order traversal of the tree above gives us the following [2,1,3,4,8]\nif node is 4 what follows is 8, thus it is the successor of the node.\n\n#### Javascript\n\n```javascript\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\nfunction findSuccessor(tree, node) {\n  let out = [];\n  inOrderTraversal(tree, out);\n  console.log(out);\n  for (let i = 0; i < out.length; i++) {\n    if (i === out.length - 1) return null;\n    if (out[i] === node) {\n      return out[i + 1];\n    } else {\n      continue;\n    }\n  }\n}\nfunction inOrderTraversal(tree, out) {\n  if (tree) {\n    inOrderTraversal(tree.left, out);\n    out.push(tree);\n    inOrderTraversal(tree.right, out);\n    return out;\n  } else {\n    return out;\n  }\n}\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.binary-trees.traverse]]\n- [[data-structures.recursion]]\n\n## Patterns\n\n- DFS\n","n":0.076}}},{"i":52,"$":{"0":{"v":"Branch Sums","n":0.707},"1":{"v":"\n## Question\n\nGiven a binary tree return a list of branch sums from left branch to right branch.\n\n#### input:\n\n```mermaid\ngraph TD;\n    1-->3;\n    1-->2;\n    2-->6;\n    2-->7;\n    3-->4;\n    3-->8;\n```\n\n#### Output:\n\n[8,12,9,10]\n\n## Solution\n\n#### Javascript\n\n```javascript\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\nfunction branchSums(root) {\n  let output = [];\n  calculateSum(root, 0, output);\n  return output;\n}\n\nfunction calculateSum(node, countingval, output) {\n  if (node === null) {\n    return;\n  }\n\n  const curentSum = countingval + node.value;\n  if (!node.left && !node.right) {\n    output.push(curentSum);\n    return;\n  }\n  calculateSum(node.left, curentSum, output);\n  calculateSum(node.right, curentSum, output);\n}\n```\n\n#### Java\n\n```java\nimport java.util.*;\n\nclass Program {\n  // This is the class of the input root. Do not edit it.\n  public static class BinaryTree {\n    int value;\n    BinaryTree left;\n    BinaryTree right;\n\n    BinaryTree(int value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  public static List<Integer> branchSums(BinaryTree root) {\n    // Write your code here.\n\t\t List<Integer> output = new ArrayList<Integer>();\n\t\t calculateSum(root,0,output);\n    return output;\n  }\n\tpublic static void calculateSum(BinaryTree node, int countingval, List<Integer> output){\n\t\tif (node == null){\n\t\t\treturn;\n\t\t}\n\t\tint currentSum = countingval + node.value;\n\t\t if (node.left == null && node.right  == null) {\n    output.add(currentSum);\n    return;\n  }\n  calculateSum(node.left, currentSum, output);\n  calculateSum(node.right, currentSum, output);\n\t}\n}\n\n```\n\n## Concepts\n\n- [[data-structures.recursion]]\n- [[data-structures.binary-trees]]\n\n## Patterns\n\n- Tree Depth First Search\n","n":0.073}}},{"i":53,"$":{"0":{"v":"Algorithms","n":1},"1":{"v":"\n- [ ] 1. Dijkstra Algorithm\n- [ ] 2. Kadane's Algorithm\n- [ ] 3. A\\* Algorithm\n- [ ] 4. Pratt Algorithm\n- [ ] 5. Topological Sort\n","n":0.196}}},{"i":54,"$":{"0":{"v":"Tries","n":1},"1":{"v":"\n## To Do\n\n- [ ] Suffix Trie construction\n- [ ] multi string search\n","n":0.277}}},{"i":55,"$":{"0":{"v":"Strings","n":1},"1":{"v":"\n## To Do\n\n- [ ] Palindrome Check\n- [ ] Caesar Cipher Encrypter\n- [ ] Run-Length Encoding\n- [ ] Generate Document\n- [ ] First Non-Repeating Character\n- [ ] Longest Palindromic Substring\n- [ ] Group Anagrams\n- [ ] Valid IP Addresses\n- [ ] Reverse Words in String\n- [ ] Minimum Character for Words\n- [ ] Longest Substring without duplicate\n- [ ] Underscorify Substring\n- [ ] Pattern Matcher\n- [ ] Smallest Substring Containing\n- [ ] Longest Balanced Substring\n","n":0.115}}},{"i":56,"$":{"0":{"v":"longest-repeating-char-replacement","n":1},"1":{"v":"\n## Question\n\nYou are given a string s lowercase letters only, and an integer k. You can choose any character of the string and change it to any other lowercase English character. You can perform this operation at most k times.\n\nyou are allowed to replace no more than k letters with any letter\n\n#### input:\n\nInput: s = \"aababba\", k = 1\n\n#### Output:\n\nOutput: 4\n\n## Solution\n\nHere we will be using our sliding window pattern to solve this, and a hash map to keep track of our characters. As we go through our array we will be also keeping count of number of times a character is repeated in our window. Then we can use this number and substract it from the window we currently have against our given k value. if the number is larger we know we cant replace the characters we have thus we have to shrink our window. We also take note of the length of the window and save it to our result. we keep repeating this throughout the whole string and return our longest substring.\n\n#### Javascript\n\n```javascript\nconst length_of_longest_substring = function (str, k) {\n  let windowStart = 0;\n  let mem = {};\n  let max = 0;\n  let numOfChar = 0;\n  for (windowEnd = 0; windowEnd < str.length; windowEnd++) {\n    char = str[windowEnd];\n    if (!(char in mem)) {\n      mem[char] = 0;\n    }\n    mem[char]++;\n    numOfChar = Math.max(numOfChar, mem[char]);\n    while (windowEnd - windowStart + 1 - numOfChar > k) {\n      let removeChar = str[windowStart];\n      mem[removeChar]--;\n      if (mem[removeChar] === 0) {\n        delete mem[removeChar];\n      }\n      windowStart++;\n    }\n    max = Math.max(max, windowEnd - windowStart + 1);\n  }\n  return max;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Sliding Window\n- Map/Set\n","n":0.061}}},{"i":57,"$":{"0":{"v":"Stacks and Queues","n":0.577},"1":{"v":"\n## Linear Data Structures\n\nStacks and Queues are linear data structures.\n\n## To Do\n\n- [ ] Min Max Stack construction\n- [ ] balanced brackets\n- [ ] sunset views\n- [ ] sort stack\n- [ ] next greater element\n- [ ] shorten path\n- [ ] largest rectangle under skyline\n","n":0.149}}},{"i":58,"$":{"0":{"v":"paired-parentheses","n":1},"1":{"v":"\n## Question\n\ngiven a string of characters return a boolean indicating whether or not the string has well-formed parentheses.\n\n#### input:\n\n(david)((abby))\n\n#### Output:\n\nTRUE\n\n## Solution\n\nThe way we can solve is using a counter, where we can increment a counter if we find an opening parentheses and decrement if we encounter a closing parentheses.\n\n#### Javascript\n\n```javascript\nconst pairedParentheses = (str) => {\n  let count = 0;\n  for (const char of str) {\n    if (char === \"(\") {\n      count++;\n    } else if (char === \")\") {\n      if (count === 0) return false;\n      count--;\n    }\n  }\n  return count === 0;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n[[data-structures.stacks]]\n\n## Patterns\n\n- iterator\n","n":0.103}}},{"i":59,"$":{"0":{"v":"decompress","n":1},"1":{"v":"\n## Question\n\ngiven a compressed string as input, return a string that is decompressed.\n\n#### input:\n\n(\"2{q}3{tu}v\")\n(\"2{y3{o}}v\")\n\n#### Output:\n\nqqtututuv\nyoooyooos\n\n## Solution\n\nas seen from our input we can have nested compressed strings so we have to evaluate our strings carefully.\n\nif we don't have any nesteed groups we could use a stack to remember the different gro\n\n#### Javascript\n\n```javascript\nconst decompressBraces = (s) => {\n  const stack = [];\n  const numbers = \"123456789\";\n\n  for (const char of s) {\n    //console.log(stack)\n    if (numbers.includes(char)) {\n      stack.push(Number(char));\n    } else {\n      if (char === \"}\") {\n        //pop routine\n        let str = \"\";\n        while (typeof stack[stack.length - 1] !== \"number\") {\n          let popped = stack.pop();\n          str = popped + str;\n        }\n        let num = stack.pop();\n        let finStr = str.repeat(num);\n        console.log(finStr);\n        stack.push(finStr);\n      } else if (char !== \"{\") {\n        stack.push(char);\n      }\n    }\n  }\n  console.log(stack);\n  return stack.join(\"\");\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n[[data-structures.stacks]]\n\n## Patterns\n\n- Stack\n","n":0.086}}},{"i":60,"$":{"0":{"v":"balanced-brackets","n":1},"1":{"v":"\n## Question\n\nGiven a string as input return a boolean indicating whether the string contains matching brackets\n\n#### input:\n\ninput = \"(){}[](<()>)\"\n\n#### Output:\n\ntrue\n\n## Solution\n\n#### Javascript\n\n```javascript\nconst stack = [];\nconst brackets = {\n  \"(\": \")\",\n  \"{\": \"}\",\n  \"[\": \"]\",\n};\nconst closingBracket = \"}])\";\n\nfor (const char of string) {\n  if (char in brackets) {\n    stack.push(brackets[char]);\n  } else if (closingBracket.includes(char)) {\n    if (stack[stack.length - 1] === char && stack.length > 0) {\n      stack.pop();\n    } else {\n      return false;\n    }\n  } else {\n    continue;\n  }\n}\nreturn stack.length === 0;\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n[[data-structures.stacks]]\n\n## Patterns\n\n- Stack\n","n":0.11}}},{"i":61,"$":{"0":{"v":"Sorting","n":1},"1":{"v":"\n## To Do\n\n- [ ] Bubble\n- [ ] Insertion\n- [ ] Selection\n- [ ] Three Number\n- [ ] Quick\n- [ ] Heap\n- [ ] Radix\n- [ ] Merge\n- [ ] Count inversions\n","n":0.177}}},{"i":62,"$":{"0":{"v":"merge-intervals","n":1},"1":{"v":"\n## Question\n\nGiven an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the mutually exclusive intervals in the input.\n\n#### input:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\n\n#### Output:\n\nOutput: [[1,6],[8,10],[15,18]]\n\n## Solution\n\nTo solve this problem we first sort our array of intervals, so that we are able to merge the overlapping intervals.\n\nFor any given interval there's six ways they relate to each other as shown below:\n![](/assets/images/2022-02-21-15-31-32.png)\n\nlets look at [1,3] and [2,6], if we check the start of our second sub array with the end of our first sub array. we see that the start of the second subarray is less. Therefore we can say theres an overlap at this interval.\n\nAs our array is sorted the starting element of our first subarray will be the start of the new sub array in our results array. To find the ending of our subarray we set it equal to the max end element of both sub arrays.\n\n```terminal\nx.start <= y.end\nz.start = x.start\nz.end = Math.max(x.end,y.end)\n/------------------/\nz.start =1;\nz.end = Math.max(3,6)=6\nz=[1,6]\n```\n\nusing the format shown we can implement that in our code below. We first sort our array based on the start number of each subarray.\n\nThen we set a start and end value to our first array, and set up a loop to start from our second subarray to implement our check algorithm outlined above.\n\n#### Javascript\n\n```javascript\nvar merge = function (intervals) {\n  merged = [];\n  if (intervals.length < 2) {\n    return intervals;\n  }\n  intervals.sort((a, b) => a[0] - b[0]);\n  let start = intervals[0][0];\n  let end = intervals[0][1];\n  for (let i = 1; i < intervals.length; i++) {\n    let currentInterval = intervals[i];\n    if (currentInterval[0] <= end) {\n      end = Math.max(end, currentInterval[1]);\n    } else {\n      merged.push([start, end]);\n      start = intervals[i][0];\n      end = intervals[i][1];\n    }\n  }\n  merged.push([start, end]);\n  return merged;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Merge Intervals\n","n":0.058}}},{"i":63,"$":{"0":{"v":"Searching","n":1},"1":{"v":"\n## To Do\n\n- [ ] Binary Search\n- [ ] Find Three Largest Numbers\n- [ ] Search in Sorted Matrix\n- [ ] Shifted Binary Search\n- [ ] Search for Range\n- [ ] Quick select\n- [ ] Index Equals Value\n","n":0.162}}},{"i":64,"$":{"0":{"v":"Recursion","n":1},"1":{"v":"\n## To Do\n\n- [ ] Nth Fibonacci\n- [ ] Product Sum\n- [ ] Permutations\n- [ ] Powerset\n- [ ] Phone Number Mnemonic\n- [ ] Staircase Traversal\n- [ ] Lowest common Manager\n- [ ] Interweaving Strings\n- [ ] Sudoku\n- [ ] Generate Div tags\n- [ ] Ambiguous Measurements\n- [ ] Number of Binary Tree Topology\n- [ ] Non-attacking Queens\n","n":0.131}}},{"i":65,"$":{"0":{"v":"Linked Lists","n":0.707},"1":{"v":"\n## To Do\n\n- [ ] Remove Duplicates From Linked List\n- [ ] Linked List Construction\n- [ ] Remove Kth Node from end\n- [ ] Reverse Linked List\n- [ ] Merge Linked List\n- [ ] Shifting Linked List\n- [ ] LRU Cache\n- [ ] Rearrange Linked List\n- [ ] Linked List palindrome\n- [ ] Zip Linked List\n- [ ] Node swap\n","n":0.129}}},{"i":66,"$":{"0":{"v":"zipper-linked-list","n":1},"1":{"v":"\n## Question\n\ngiven the head of two singly linked lists, zip the two linked list into a single linked list of alternating nodes. if one is longer than the other, the list should terminate with the remaining nodes.\n\nboths inputs are non empty, and do not mutate original nodes. your function should return the head of the zipped linked list\n\n#### input:\n\n```mermaid\nflowchart TB\n    subgraph one\n    4-->5\n    5-->6\n    6\n    end\n    subgraph two\n   1-->2\n    2-->3\n    3\n    end\n\n```\n\n#### Output:\n\n```mermaid\nflowchart TB\n    subgraph zipped\n    1-->4\n    4-->2\n    2-->5\n    5-->3\n    3-->6\n    6\n    end\n\n\n```\n\n## Solution\n\nNow we can solve this question using two pointers to keep track of the two linked list, and another pointer to keep track of the tail of our new node.\n\n#### Javascript\n\n```javascript\n\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[data-structures.linked-list.single-linked-list]]\n\n## Patterns\n\n- Two Pointer/Iterator\n","n":0.091}}},{"i":67,"$":{"0":{"v":"unique-value","n":1},"1":{"v":"\n## Question\n\ngiven a head of a linked list return a boolean indicating whether there exists exactly one unique value.\n\n#### input:\n\nLink 1\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n    2-->6;\n    6-->7;\n    7-->4;\n```\n\nLink 2\n\n```mermaid\ngraph LR;\n    g[1]-->g2[1];\n    g2[1]-->g3[1];\n```\n\n#### Output:\n\nFALSE\n\nTRUE\n\n## Solution\n\nwe can solve this using a set or a variable to hold the first value of our head, and check if all the nodes in the list contain exactly the same value, if not we can simply return false.\n\n#### Javascript\n\n```javascript\nconst isUniqueValueList = (head) => {\n  // todo\n  const set = new Set();\n  set.add(head.val);\n  while (head !== null) {\n    if (!set.has(head.val)) {\n      return false;\n    }\n    head = head.next;\n  }\n  return true;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[data-structures.linked-list.single-linked-list]]\n\n## Patterns\n\n- Map/Set\n","n":0.096}}},{"i":68,"$":{"0":{"v":"middle-of-linked-list","n":1},"1":{"v":"\n## Question\n\nGiven the head of a singly linked list, return the middle node of the linked list.\n\nIf there are two middle nodes, return the second middle node.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->7;\n    7-->4;\n```\n\n#### Output:\n\n7\n\n## Solution\n\nwe will have two pointers, our second pointer will be moving through our list two steps at a time. So if that pointer reaches the end of our list, we know that our first pointer is at the middle of our linked list.\n\n#### Javascript\n\n```javascript\nvar middleNode = function (head) {\n  let p1 = head,\n    p2 = head;\n  while ((p2 !== null) & (p2.next !== null)) {\n    p1 = p1.next;\n    p2 = p2.next.next;\n    if (p2 == null) break;\n  }\n  return p1;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n\n## Patterns\n\n- Two Pointers\n","n":0.092}}},{"i":69,"$":{"0":{"v":"longest-streak","n":1},"1":{"v":"\n## Question\n\nGiven a head of a linked list, return the longest consecutive streak of a node with the same value.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n    2-->6;\n    6-->7;\n```\n\n#### Output:\n\n1\n\n## Solution\n\nTo solve this we can use a map to store the values of the nodes as key and their frequency. We can do this for all nodes, incrementing their frequency value if we find one that is consecutive. We have to reset though if we find the same element is not consecutive. Thus we use a previous variable to keep track of the value of the previous node.\n\n#### Javascript\n\n```javascript\nconst mem = {};\nvar max = 0;\nvar prev = null;\nwhile (head !== null) {\n  if (!mem[head.val]) {\n    mem[head.val] = 1;\n    prev = head;\n  } else {\n    if (head.val !== prev.val && mem[head.val] > 0) {\n      mem[head.val] = 1;\n    } else {\n      mem[head.val] += 1;\n    }\n  }\n  console.log(mem);\n  prev = head;\n  max = Math.max(mem[head.val], max);\n  head = head.next;\n}\nreturn max;\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[data-structures.linked-list.single-linked-list]]\n\n## Patterns\n\n- Two Pointer/Iterator\n- Map/Set\n","n":0.079}}},{"i":70,"$":{"0":{"v":"insert-node","n":1},"1":{"v":"\n## Question\n\ngiven a head of a linked list, a value, and an index. insert the value at the given index within the list.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n```\n\nindex=2\nvalue=4\n\n#### Output:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->4;\n    4-->2;\n```\n\n## Solution\n\nSimilar to our delete node function, we need to keep track of the previous node in the list. We can then traverse through our list, until we are at the specified index. at that point we can add our new node with the value to the list\n\n#### Javascript\n\n```javascript\nconst insertNode = (head, value, index) => {\n  let count = 0;\n  var prev = null;\n  var current = head;\n  let newNode = new Node(value);\n  while (current !== null) {\n    if (count === index) {\n      break;\n    }\n    count++;\n    prev = current;\n    current = current.next;\n  }\n  console.log(count, index);\n  if (prev === null) {\n    newNode.next = current;\n    return newNode;\n  } else {\n    prev.next = newNode;\n    newNode.next = current;\n  }\n  return head;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[data-structures.linked-list.single-linked-list]]\n\n## Patterns\n\n- Two Pointer/Iterator\n","n":0.08}}},{"i":71,"$":{"0":{"v":"happy-number","n":1},"1":{"v":"\n## Question\n\nWrite an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the following process:\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\nRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\nThose numbers for which this process ends in 1 are happy.\nReturn true if n is a happy number, and false if not.\n\n#### input:\n\nInput: n = 19\n\n#### Output:\n\n```mermaid\ngraph LR;\n    19-->82;\n    82-->68;\n    68-->100;\n    100-->1;\n\n```\n\nOutput: true\n\n## Solution\n\nFor this given problem, we know that for a given number it will be stuck on 1 or a different set of number. So what we can do is go through a loop until we find a cycle. Once we have reached a cycle we can break and check if the number is equal to 1 and return boolean result.\n\n#### Javascript\n\n```javascript\nvar isHappy = function (num) {\n  let p1 = num,\n    p2 = num;\n  while (true) {\n    p1 = find_square_sum(p1);\n    p2 = find_square_sum(find_square_sum(p2));\n    if (p1 === p2) {\n      break;\n    }\n  }\n  return p1 === 1;\n};\n\nfunction find_square_sum(num) {\n  let sum = 0;\n  while (num > 0) {\n    digit = num % 10;\n    sum += digit * digit;\n    num = Math.floor(num / 10);\n  }\n  return sum;\n}\n// or\nvar isHappy = function (num) {\n  let p1 = num;\n  const mem = new Set();\n  while (true) {\n    p1 = find_square_sum(p1);\n    if (mem.has(p1)) break;\n    mem.add(p1);\n  }\n  return p1 === 1;\n};\n\nfunction find_square_sum(num) {\n  let sum = 0;\n  while (num > 0) {\n    digit = num % 10;\n    sum += digit * digit;\n    num = Math.floor(num / 10);\n  }\n  return sum;\n}\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[Problems.linked-lists.cycle]]\n\n## Patterns\n\n- Two Pointer;\n- Map/Set\n","n":0.06}}},{"i":72,"$":{"0":{"v":"delete-node","n":1},"1":{"v":"\n## Question\n\nGiven the head of a singly linked list, and a target value. Delete only the first instance of the node with the target value and return the head of the list.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n    2-->6;\n```\n\ntarget= 3\n\n#### Output:\n\n```mermaid\ngraph LR;\n    1-->2;\n    2-->6;\n```\n\n## Solution\n\nWe can simply iterate over the list until we find a node with the same value as our target value. Once we have that we can simply set the next of our previous node to our next node of the current node we are on. Then we can simply set our node of our current node to null. As this is a singly linked list we need a variable to track the previous node.\n\n#### Javascript\n\n```javascript\nconst removeNode = (head, targetVal) => {\n  var current = head;\n  var previous = null;\n  while (current !== null) {\n    if (current.val === targetVal) {\n      break;\n    }\n    previous = current;\n    current = current.next;\n  }\n  if (previous === null) {\n    head = current.next;\n    current.next = null;\n  } else {\n    previous.next = current.next;\n    current.next = null;\n  }\n  return head;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[data-structures.linked-list.single-linked-list]]\n\n## Patterns\n\n- Two Pointer/Iterator\n","n":0.075}}},{"i":73,"$":{"0":{"v":"cycle","n":1},"1":{"v":"\n## Question\n\nGiven head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n    2-->4;\n    4-->3;\n\n```\n\n#### Output:\n\nOutput: true\n\n## Solution\n\nIf we want to find a cycle within a linked list we can use the fast and slow pointer pattern to find our solution. We will have our slow pointer iterate through the linked list step by step, and we will have our fast pointer move 2 steps each time.\n\nWe will know if we have a cycle in our list if both our pointers have equal value, if so we can simply return false.\n\nAnother way we can solve this is using a set to keep track of our nodes in the list as we traverse through our linked list. If we find we have the same node as in our set, we can simply return true as we are in a cycle.\n\n#### Javascript\n\n```javascript\nvar hasCycle = function (head) {\n  let p1 = head,\n    p2 = head;\n  while (p2 !== null && p2.next !== null) {\n    p2 = p2.next.next;\n    p1 = p1.next;\n    if (p1 === p2) {\n      return true;\n    }\n  }\n  return false;\n};\n//or\nvar hasCycle = function (head) {\n  const mem = new Set();\n  return help(head, mem);\n};\nconst help = (node, mem) => {\n  if (mem.has(node)) return true;\n  if (!node) return false;\n  mem.add(node);\n  return help(node.next, mem);\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n\n## Patterns\n\n- Fast & Slow Pointers\n- Map/Set\n","n":0.058}}},{"i":74,"$":{"0":{"v":"cycle-start","n":1},"1":{"v":"\n## Question\n\nGiven the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\n\nDo not modify the linked list.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n    2-->4;\n    4-->3;\n\n```\n\n#### Output:\n\n3\n\n## Solution\n\nWe can solve this using either a fast and slow pointer or a set.\n\nFor the fast and slow pointer approach. we will need to make use of two functions, one will find the length of our cycle, and once we find our length we can find our starting point using another function. We will pass our length of the cycle and head of the linked list to that function, and increment our second/fast pointer by the length of the cycle. Then we loop through the cycle until we find that both pointers are equal. At that point we can simply return any pointer as that is our starting point.\n\nIf we use the set approach, we will simply iterate through the array, and once we reach a value that is already in our set. We can simply return it as that node is where the cycle begins.\n\n#### Javascript\n\n```javascript\nvar detectCycle = function (head) {\n  let p1 = head,\n    p2 = head;\n  while (p2 !== null && p2.next !== null) {\n    p2 = p2.next.next;\n    p1 = p1.next;\n    if (p1 === p2) {\n      let length = lengthCycle(p2);\n      return startCycle(head, length);\n    }\n  }\n  return null;\n};\nvar lengthCycle = function (p2) {\n  let count = 0,\n    p1 = p2;\n  while (p1 !== null) {\n    p1 = p1.next;\n    count++;\n    if (p2 === p1) {\n      break;\n    }\n  }\n  return count;\n};\nvar startCycle = function (head, length) {\n  let p1 = head,\n    p2 = head;\n  for (let i = 0; i < length; i++) {\n    p2 = p2.next;\n  }\n  while (p2 !== p1) {\n    p1 = p1.next;\n    p2 = p2.next;\n  }\n  return p1;\n};\n\n//// OR\nvar detectCycle = function (head) {\n  const mem = new Set();\n  return help(head, mem);\n};\nconst help = (node, mem) => {\n  if (!node) return null;\n  if (!mem.has(node)) {\n    mem.add(node);\n  } else {\n    return node;\n  }\n  return help(node.next, mem);\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[Problems.linked-lists.cycle-length]]\n\n## Patterns\n\n- Fast & Slow pointer\n- Map/set\n","n":0.05}}},{"i":75,"$":{"0":{"v":"cycle-length","n":1},"1":{"v":"\n## Question\n\nGiven the head of a linked list, return the length of the cycle. If there is no cycle, return null.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n    2-->4;\n    4-->3;\n\n```\n\n#### Output:\n\noutput:3\n\n## Solution\n\nTo solve this we can use similar approach as the first cycle problem, Once we have reached a point where we have found a cycle, we can call a function which then goes through the list from the point the cycle was found to find the length of our cycle in our list.\n\n#### Javascript\n\n```javascript\nvar lengthCycle = function (head) {\n  let p1 = head,\n    p2 = head;\n  while (p2 !== null && p2.next.next !== null) {\n    p2 = p2.next.next;\n    p1 = p1.next;\n    if (p1 === p2) {\n      return help(p2);\n    }\n  }\n  return null;\n};\nconst help = (p2) => {\n  let count = 0,\n    p1 = p2;\n  while (p1 !== null) {\n    p1 = p1.next;\n    count++;\n    if (p2 === p1) {\n      break;\n    }\n  }\n  return count;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[Problems.linked-lists.cycle]]\n\n## Patterns\n\n- Fast & Slow Pointers\n","n":0.079}}},{"i":76,"$":{"0":{"v":"create-linked-list","n":1},"1":{"v":"\n## Question\n\nGiven an array of values, create a linked list containing each element of the array.\n\n#### input:\n\n[1,2,3,4]\n\n#### Output:\n\n```mermaid\ngraph LR;\n    1-->2;\n    2-->3;\n    3-->4;\n```\n\n## Solution\n\nWe first create a dummy node head which is null and have our current pointer set to that head. Then we\nWe can solve this by simply iterating over the array, and setting the next value of our current pointer to the new node.\nwe can then return the next our dummy head to get the head of our newly created linked list.\n\n#### Javascript\n\n```javascript\nconst createLinkedList = (values) => {\n  var head = new Node(null);\n  var current = head;\n  for (const val of values) {\n    var newNode = new Node(val);\n    current.next = newNode;\n    current = current.next;\n  }\n  return head.next;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[data-structures.linked-list.single-linked-list]]\n\n## Patterns\n\n- Two Pointer/Iterator\n","n":0.089}}},{"i":77,"$":{"0":{"v":"add-lists","n":1},"1":{"v":"\n## Question\n\ngiven two heads of linked list, sum the nodes of the linked lists and return a new linked list representing the sum.\n\n#### input:\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n```\n\n```mermaid\ngraph LR;\n    1-->3;\n    3-->2;\n```\n\n#### Output:\n\n```mermaid\ngraph LR;\n    2-->6;\n    6-->4;\n```\n\n## Solution\n\nWe can solve this by first having two pointers to keep track of the two lists, and creating our new linked list. Once we have everything set up we can iterate through the lists. at each node we will check if the current node is null and assign a temporary variable with 0 or the node value. We can then simply add the two temp variables and our float/carry number. we can then add our new node to the list containing our sum value and iterate through the list with our new carry/float value if there is one.\n\n#### Javascript\n\n```javascript\nconst addLists = (head1, head2) => {\n  // todo\n  var current1 = head1;\n  var current2 = head2;\n  let Result = new Node(null);\n  let Head = Result;\n  let float = 0;\n  while (current1 !== null || current2 !== null || float !== 0) {\n    let val1 = current1 === null ? 0 : current1.val;\n    let val2 = current2 === null ? 0 : current2.val;\n    let temp = val1 + val2 + float;\n    float = temp > 9 ? 1 : 0;\n    let remainder = temp % 10;\n    Result.next = new Node(remainder);\n    Result = Result.next;\n    if (current1 !== null) current1 = current1.next;\n    if (current2 !== null) current2 = current2.next;\n  }\n  return Head.next;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.linked-list]]\n- [[data-structures.linked-list.single-linked-list]]\n\n## Patterns\n\n- Two Pointer/Iterator\n","n":0.063}}},{"i":78,"$":{"0":{"v":"Heaps","n":1},"1":{"v":"\n## To Do\n\n- [ ] Min Heaps Construction\n- [ ] Continuous Median\n- [ ] Sort K-Sorted Array\n- [ ] Laptop Rentals\n- [ ] Merge Sorted Arrays\n","n":0.196}}},{"i":79,"$":{"0":{"v":"Greedy Algorithms","n":0.707},"1":{"v":"\n## To Do\n\n- [ ] Minimum Waiting time\n- [ ] Class photos\n- [ ] Tandem Bicycle\n- [ ] Task Assignment\n- [ ] Valid Starting City\n","n":0.2}}},{"i":80,"$":{"0":{"v":"Dynamic Programming","n":0.707},"1":{"v":"\n## To Do\n\n- [ ] Max Subset sum No Adjacent\n- [ ] Number of ways to make change\n- [ ] min number of coins for change\n- [ ] levenshtein distance\n- [ ] max sum increasing subsequence\n- [ ] longest common subsequence\n- [ ] min number of jumps\n- [ ] water area\n- [ ] knapsack problem\n- [ ] disk stacking\n- [ ] numbers in pi\n- [ ] maximum sum submatrix\n- [ ] maximize expression\n- [ ] max profit with k transactions\n- [ ] palindrome partitioning min cuts\n- [ ] longest increasing subsequence\n- [ ] longest string chain\n- [ ] square of zeroes\n","n":0.1}}},{"i":81,"$":{"0":{"v":"HowSum","n":1},"1":{"v":"\n## Question\n\nGiven a target sum and an array of integers, return any combination of array elements that equals the target sum. if there is no combination the function should return null.\nyou can use an element of the array as many times as needed, and all elements are positive.\n\n#### input:\n\ntarget = 7;\narray = [2,4]\n\n#### Output:\n\noutput = Null\n\n## Solution\n\nAs we have done previously we can visualize this problem in a form of a tree.\nif we were given a target sum of 7, and an array which contains [5,4,3,7], we can visualize the problem as shown below.\n![](/assets/images/2022-02-07-12-23-57.png)\nAs can be seen in the graph we have three ways of getting our target sum as we have nodes that reach 0.\n\n#### Javascript\n\n```javascript\nfunction howSum(array, targetSum, mem = {}) {\n  if (targetSum === 0) return [];\n  if (targetSum < 0) return null;\n  if (targetSum in mem) return mem[targetSum];\n  for (const num of array) {\n    const remainder = targetSum - num;\n    var remainderResult = fourNumberSum(array, remainder, mem);\n    if (remainderResult !== null) {\n      mem[targetSum] = [...remainderResult, num];\n      return mem[targetSum];\n    }\n  }\n  mem[targetSum] = null;\n  return mem[targetSum];\n}\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n[[data-structures.recursion]]\n\n## Patterns\n\n- Map/Set\n","n":0.074}}},{"i":82,"$":{"0":{"v":"grid-traveler","n":1},"1":{"v":"\n## Question\n\nGiven a grid size of m by n, starting at the most left corner how many ways can you reach the bottom right corner of the grid.\n\nYou can only travel down or right through the grid.\n\n#### input:\n\ngrid(2,3);\n\n#### Output:\n\npossible moves: 3\n\n## Solution\n\nTo complete this lets first visualize the problem.\n![](/assets/images/2022-02-07-10-14-43.png)\n\nAs seen in the graph below if were given a grid of 3 by 3. we can see all the possible moves that we can make to reach the end of the grid. We can also see we have locations that keep repeating, thus what we can do is similar to our fibonacci solution where we can save the return statement(value) of that given point in our function. reducing the steps needed to reach the end of the grid.\n\n#### Javascript\n\n```javascript\nconst gridTraveler = (m, n, mem = {}) => {\n  if (m === 1 && n === 1) return 1;\n  if (m === 0 || n === 0) return 0;\n  var position = m + \",\" + n;\n  if (position in mem) return mem[position];\n  mem[position] = gridTraveler(m - 1, n, mem) + gridTraveler(m, n - 1, mem);\n  return mem[position];\n};\n\nconsole.log(gridTraveler(18, 18));\n//2333606220\n// O (m*n) Time\n// O(m+n) space\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n[[data-structures.recursion]]\n\n## Patterns\n\n- Map/Set\n","n":0.071}}},{"i":83,"$":{"0":{"v":"fibonacci","n":1},"1":{"v":"\n## Question\n\nThe Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven n, calculate F(n).\n\n0 <= n <= 100\n\n#### input:\n\nF(0)\n\n#### Output:\n\noutput = 0\n\n## Solution\n\nWe cant do a simple recursion as done previously for our solution. our given n might be 50, 60 or higher. That means that our function will have to recursively step through way over million steps to complete. Thus we need to implement Memoization to save some answers to our sub problems.\n\nif we look at the fibonacci graph below we can see that the sub tree of 3 occurs twice once on the right and on the left. That means if we save the return value of 3 on our first run every time we face a similar node we can simply return that value.\n\n![](/assets/images/2022-02-07-09-56-32.png)\n\n#### Javascript\n\n```javascript\nvar fib = function (n, mem = {}) {\n  if (n in mem) return mem[n];\n  if (n === 0) return 0;\n  if (n === 1 || n <= 2) return 1;\n\n  mem[n] = fib(n - 1, mem) + fib(n - 2, mem);\n  return mem[n];\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.recursion]]\n\n## Patterns\n\n- Set/Map\n","n":0.068}}},{"i":84,"$":{"0":{"v":"canSum","n":1},"1":{"v":"\n## Question\n\ngiven an array and a target sum, return true if there is a combination of two numbers that equal the target.\n\nyou can use an element of the array as many times as needed, and all elements are positive.\n\n#### input:\n\ntarget = 3;\narray =[4,2,1,5]\n\n#### Output:\n\noutput = true;\n\n## Solution\n\n#### Javascript\n\n```javascript\nconst canSum = (target, array, mem = {}) => {\n  if (target === 0) return true;\n  if (target < 0) return false;\n  if (target in mem) return mem[target];\n  for (const num of array) {\n    const remainder = target - num;\n    if (canSum(remainder, array, mem) === true) {\n      mem[target] = true;\n      return mem[target];\n    }\n  }\n  mem[target] = false;\n  return mem[target];\n};\n/*\nm = target sum, and n = length of array.\nbrute force approach gives us O(n^m) time complexity and O(m) space complexity\nfor this memoization approach we have\nO(m*n) time complexity\nO(m) space complexity\n*/\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n[[data-structures.recursion]]\n\n## Patterns\n\n- Map/Set\n","n":0.085}}},{"i":85,"$":{"0":{"v":"Binary Search Trees","n":0.577},"1":{"v":"\n## Binary Search Tree Problems To Do\n\n- [ ]\n- [ ] BST Construction\n- [ ] Validate BST\n- [ ] BST Traversal\n- [ ] Min Height BST\n- [ ] Find Kth Largest Value in BST\n- [ ] Reconstruct BST\n- [ ] Same BST\n- [ ] Validate Three Nodes\n- [ ] MRight Smaller Than\n","n":0.139}}},{"i":86,"$":{"0":{"v":"find-closest-value-in-bst","n":1},"1":{"v":"\nFind Closest Value in BST\n\n## Question\n\nGiven a binary search tree and a target integer, return the closest value to the target in contained in the bst.\n\n#### input:\n\n```mermaid\ngraph TD;\n    10-->5;\n    10-->13;\n    5-->2;\n    5-->7;\n    13-->12;\n    13-->18;\n```\n\nTarget value : 11\n\n#### Output:\n\noutput: 12\n\n## Solution\n\n#### Javascript\n\n```javascript\nfunction findClosestValueInBst(tree, target) {\n  return BSTHelper(tree, target, tree.value);\n}\nfunction BSTHelper(tree, target, output) {\n  if (tree === null) {\n    return output;\n  } else if (Math.abs(target - output) > Math.abs(target - tree.value)) {\n    output = tree.value;\n  }\n\n  if (tree.value < target) {\n    return BSTHelper(tree.right, target, output);\n  } else if (tree.value > target) {\n    return BSTHelper(tree.left, target, output);\n  } else {\n    return output;\n  }\n}\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.binary-trees.search-trees]]\n- [[data-structures.binary-trees.traverse]]\n\n## Patterns\n\n- Modified Binary Search\n","n":0.096}}},{"i":87,"$":{"0":{"v":"Arrays","n":1},"1":{"v":"\n## To Do\n\n- [ ] two number sum\n- [ ] validate subsequence\n- [ ] sorted squared array\n- [ ] tournament winner\n- [ ] non-constructible change\n- [ ] three number sum\n- [ ] smallest difference\n- [ ] move element to end\n- [ ] monotonic array\n- [ ] spiral traverse\n- [ ] longest peak\n- [ ] array of products\n- [ ] first duplicate value\n- [ ] merge overlapping intervals\n- [ ] four number sum\n- [ ] subarray sort\n- [ ] largest range\n- [ ] min rewards\n- [ ] zigzag traverse\n- [ ] apartment hunting\n- [ ] calendar matching\n- [ ] watrerfall streams\n- [ ] minimum area rectangle\n- [ ] line through points\n","n":0.095}}},{"i":88,"$":{"0":{"v":"uncompress-string","n":1},"1":{"v":"\n## Question\n\nGiven a String as an input, uncompress each character and repeat it based on the number indicated.\n\n#### input:\n\nuncompress(\"2c3a1t\")\n\n#### Output:\n\n'ccaaat'\n\n## Solution\n\nWe can solve this by iterating over our string input. First we can have an array of possible numbers in the string to check each character against.\n\nWe will then have to pointers to loop through the array. for our first pointer, as we loop we check to see that the character currently is in our number array. If it's in our number array we simply increment our first pointer.\n\nOnce we reach a character which is not in our number array we take a slice from our second pointer which is at the start to our first pointer. This will give us the number we need to repeat our given character.\n\nNow we take our given character and use a simple for loop or repeat function to push our repeated character into our results array. After we have pushed our array we then simply equal our second pointer to our first pointer, and increment our first pointer. We then go through this loop until we have reached the end of our string.\n\n#### Javascript\n\n```javascript\nconst uncompress = (s) => {\n  let result = [];\n  const numbers = \"0123456789\";\n  let i = 0;\n  let j = 0;\n  while (j < s.length) {\n    if (numbers.includes(s[j])) {\n      j += 1;\n    } else {\n      const num = Number(s.slice(i, j));\n      for (let count = 0; count < num; count += 1) {\n        result.push(s[j]);\n      }\n      j += 1;\n      i = j;\n    }\n  }\n  return result.join(\"\");\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n[[data-structures.arrays]]\n\n## Patterns\n\n- Two Pointers\n- One Fast one Slow pointer\n","n":0.061}}},{"i":89,"$":{"0":{"v":"two-sum","n":1},"1":{"v":"\n## Question\n\nGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\n#### input:\n\nInput: numbers = [2,7,11,15], target = 9\n\n#### Output:\n\nOutput: [1,2]\n\n## Solution\n\nThis question comes in different varieties, it might be sorted or not sorted, and might ask for index values or the actual values as well. But the solution stays the same only what you return is different. Now we can solve this using two ways, one is simpler and easier than other.\n\nThe first way we will solve this is using hashmaps, and then we will solve it using two pointers( as it is already sorted).\n\nFor our first way, we can simply subtract from target sum our current value and check if the result is in our hashmap. As A+B = X, A=X-B. Thus, if it's not in our map we simply add it to our hashmap and keep iterating through our array.\n\nFor our second solution, as our array is already sorted we can use two pointers, one at both ends of the array. Then we can increment from both sides until we find a value which matches our target. We will increment our value depending on the value of our current sum, if the current sum is greater than our target value we need to decrease our current value. So we will decrease our pointer at the end of our array and if it's less than our target value then we need to increase our value. Therefore we increase our pointer to the left of the array. If the array is not sorted we would need to sort it, which means that we would add an O(nlog(n)) complexity to our solution.\n\n#### Javascript\n\n```javascript\nvar twoSum = function (numbers, target) {\n  const previousNums = {};\n  for (let i = 0; i < numbers.length; i += 1) {\n    const num = numbers[i];\n    const complement = target - num;\n    if (complement in previousNums)\n      return [previousNums[complement] + 1, i + 1];\n\n    previousNums[num] = i;\n  }\n};\n//Or\nvar twoSum = function (numbers, target) {\n  let p1 = 0;\n  let p2 = numbers.length - 1;\n  while (p1 < p2) {\n    let current_Sum = numbers[p1] + numbers[p2];\n    if (current_Sum === target) {\n      return [p1 + 1, p2 + 1];\n    } else if (current_Sum < target) {\n      p1++;\n    } else {\n      p2--;\n    }\n  }\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Two Pointers\n- HashMap\n","n":0.047}}},{"i":90,"$":{"0":{"v":"three-sum-smallest","n":1},"1":{"v":"\n## Question\n\nGiven an array arr of unsorted numbers and a target sum, count all triplets in it such that arr[i] + arr[j] + arr[k] < target where i, j, and k are three different indices. Write a function to return the count of such triplets.\nFind count of triplets with sum smaller than given sum value\n\n#### input:\n\nInput: nums = [-2, 0, 1, 3] target = 2;\n\n#### Output:\n\nOutput: 2, because [[-2, 0, 1],[-2, 0, 3]]\n\n## Solution\n\nTo solve this we follow the same pattern as previously for the three sum problem, except this time we just increment our counter variable each time we reach a value where our sum of two pairs is greater than the target value.\n\n#### Javascript\n\n```javascript\nconst triplet_with_smaller_sum = function (arr, target) {\n  count = 0;\n  arr.sort((a, b) => a - b);\n  for (let i = 0; i < arr.length - 2; i++) {\n    if (i > 1 && arr[i] === arr[i - 1]) continue;\n    let p1 = i + 1;\n    count += helper(arr, p1, target - arr[i]);\n  }\n\n  return count;\n};\n\nconst helper = (arr, p1, target_s) => {\n  let p2 = arr.length - 1;\n  let count = 0;\n  while (p1 < p2) {\n    let currentSum = arr[p1] + arr[p2];\n    if (currentSum < target_s) {\n      count += p2 - p1; //there can be total p2-p1 third elements.\n      console.log(count);\n      p1++;\n    } else {\n      p2--;\n    }\n  }\n  return count;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n- [[Problems.arrays.three-number-sum]]\n\n## Patterns\n\n- Two Pointer\n","n":0.066}}},{"i":91,"$":{"0":{"v":"three-sum-closest","n":1},"1":{"v":"\n## Question\n\nGiven an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n\nReturn the sum of the three integers.\n\nYou may assume that each input would have exactly one solution.\n\n#### input:\n\nInput: nums = [-1,2,1,-4], target = 1\n\n#### Output:\n\nOutput: 2\n\n## Solution\n\nThis is exactly the same as our previous solution for three sum problem, but this time we sill save the sum of each value and return the smallest sum value at the end.\nAs done previously, we will first sort our array, then we will iterate through our array.\n\nat each current value we go through a while loop to check for possible combinations of values to find the smallest sum value, if we find a combination that is equal to our target sum or it's difference is 0. we can simply return this value. Otherwise for each combination sum we check it with our current smallest value, and save it if it's smaller than our current smallest sum.\n\n#### Javascript\n\n```javascript\nvar threeSumClosest = function (arr, target_sum) {\n  let smallestSum = Infinity;\n  arr.sort((a, b) => a - b);\n  for (let i = 0; i < arr.length - 2; i++) {\n    let p1 = i + 1;\n    let p2 = arr.length - 1;\n    while (p1 < p2) {\n      let targetDiff = target_sum - arr[i] - arr[p1] - arr[p2];\n      if (targetDiff === 0) {\n        return target_sum;\n      }\n\n      if (Math.abs(targetDiff) < Math.abs(smallestSum)) {\n        smallestSum = targetDiff;\n      }\n\n      if (targetDiff > 0) {\n        p1++;\n      } else {\n        p2--;\n      }\n    }\n  }\n  return target_sum - smallestSum;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n- [[Problems.arrays.three-number-sum]]\n\n## Patterns\n\n- Two Pointer\n","n":0.061}}},{"i":92,"$":{"0":{"v":"three-number-sum","n":1},"1":{"v":"\n## Question\n\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n#### input:\n\nInput: nums = [-1,0,1,2,-1,-4]\n\n#### Output:\n\nOutput: [[-1,-1,2],[-1,0,1]]\n\n## Solution\n\nFor our three sum solution, we can first sort our array, then attempt to solve this. As sorting our array would take less time than finding the solution( the added complexity can be ignored).\n\nThe way in which we can solve this is by implementing the solution of a two sum problem into this, As our array is sorted we put our first pointer as the next one in to this value, and send it to our two sum helper function as the target value. Because A+B+C=0, so -C=A+B. Therefore we send to our two sum function our array, first pointer, target value and our triplet array.\n\nIn our Two Sum function we can approach this using two pointers instead of using sets as done previously. we will have our second pointer pointing to the end of our array, and do a while loop. In our while loop we check if the sum of the two values of our pointer is equal to our target value. If it equals the target value we can simply push it into our triplets array the three values needed, and increment our pointers. As we need to avoid having duplicate triplets, we do another while loop inside our if statement to skip same elements for both our pointers.\n\nIf our current sum does not equal our target value then we can simply increase our pointers. If our current sum is less than the target sum we need a bigger current sum, so we increment our first pointer, and vice versa for our second pointer. Once we have tried all combination we simply return our triplet array. In our original array before we call our helper function we also need to check if we have the same element and skip it in order to avoid duplicate triplets in our triplets array.\n\n#### Javascript\n\n```javascript\nvar threeSum = function (arr) {\n  triplets = [];\n  arr.sort((a, b) => a - b);\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0 && arr[i] === arr[i - 1]) {\n      continue;\n    }\n    help(arr, i + 1, -arr[i], triplets);\n  }\n  return triplets;\n};\nconst help = (arr, p1, target_Sum, triplets) => {\n  let p2 = arr.length - 1;\n  while (p1 < p2) {\n    currentSum = arr[p1] + arr[p2];\n    if (currentSum === target_Sum) {\n      triplets.push([-target_Sum, arr[p1], arr[p2]]);\n      p2--;\n      p1++;\n      while (arr[p1] === arr[p1 - 1]) p1++;\n      while (arr[p2] === arr[p2 + 1]) p2--;\n    } else if (currentSum < target_Sum) {\n      p1++;\n    } else {\n      p2--;\n    }\n  }\n  return triplets;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n- [[Problems.arrays.two-sum]]\n\n## Patterns\n\n- Two Pointer\n","n":0.046}}},{"i":93,"$":{"0":{"v":"square-sorted-array","n":1},"1":{"v":"\n## Question\n\nGiven an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n\n#### input:\n\nInput: nums = [-4,-1,0,3,10]\n\n#### Output:\n\nOutput: [0,1,9,16,100]\n\n## Solution\n\nWe can solve this easily by brute forcing a solution by first squaring our array and then sorting it using a function of the language program, as seen in the first solution. But this is not the optimal solution, as it adds an O(nlog(n)) complexity to our solution. What we can do is use two pointers one at each end and compare the resulting square of both numbers to fill our squares array in order, starting from the highest value in our sorted square array.\n\n#### Javascript\n\n```javascript\nconst sortedSquares = function (arr) {\n  squares = [];\n  console.log(arr);\n  for (let i = 0; i < arr.length; i++) {\n    squares.push(arr[i] * arr[i]);\n  }\n  squares.sort((a, b) => a - b);\n  return squares;\n};\n// OR\nconst sortedSquares = function (arr) {\n  squares = new Array(arr.length).fill(0);\n  let p1 = 0;\n  let p2 = arr.length - 1;\n  let highestValue = p2;\n  while (p1 <= p2) {\n    let leftValue = arr[p1] * arr[p1];\n    let rightValue = arr[p2] * arr[p2];\n    if (rightValue > leftValue) {\n      squares[highestValue] = rightValue;\n      p2--;\n    } else {\n      squares[highestValue] = leftValue;\n      p1++;\n    }\n    highestValue--;\n  }\n  return squares;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Two Pointer\n","n":0.068}}},{"i":94,"$":{"0":{"v":"sort-colors/ Dutch Flag Problem","n":0.5},"1":{"v":"\n## Question\n\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.\n\n#### input:\n\nInput: nums = [2,0,2,1,1,0]\n\n#### Output:\n\nOutput: [0,0,1,1,2,2]\n\n## Solution\n\nTo solve this we will have two pointers one at each end of the array, then we have a simple while loop in place. In the while loop we check if the current value we're at is equal to 0, if so we swap values on the spot with our left pointer and increment our left pointer and i. We do the same if we find that our current value is equal to 2, we swap it with that value and decrement our right pointer. if it doesn't meet these two conditions it's a one so we simply just increment i.\n\n#### Javascript\n\n```javascript\nvar sortColors = function (arr) {\n  let p1 = 0,\n  let i = 0;\n  let p2 = arr.length - 1;\n  while (i <= p2) {\n    if (arr[i] === 0) {\n      [arr[i], arr[p1]] = [arr[p1], arr[i]];\n      i++;\n      p1++;\n    } else if (arr[i] === 2) {\n      [arr[i], arr[p2]] = [arr[p2], arr[i]];\n      p2--;\n    } else {\n      i++;\n    }\n  }\n  return arr;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Two Pointer\n","n":0.066}}},{"i":95,"$":{"0":{"v":"smallest-subarray-with-greater-sum","n":1},"1":{"v":"\n## Question\n\nGiven an array of integers, find the length of the smallest contiguous subarray where the sum is greater than or equal to S.\n\n#### input:\n\nInput: [2, 1, 5, 2, 3, 2], S=7\n\n#### Output:\n\nOutput: 2\n\n## Solution\n\nWe can approach this problem by using the sliding window pattern, but compared to the previous implementations here we have to dynamically change the size of the window as we progress.\n\nWe first start incrementing the windowEnd until we have a sum value which is greater than or equal to S. Once we reach that point we take the length of the array by substracting our window end and start.\n\nWe then increment our windowStart, and subtract that value from our current sum. Then we continue this process to get new lengths and comparing that length to our previous length and storing the smallest length to return.\n\n#### Javascript\n\n```javascript\nconst smallest_subarray_sum = function (s, arr) {\n  let windowStart = 0;\n  let windowSum = 0;\n  let minLength = Infinity;\n  for (windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n    windowSum += arr[windowEnd];\n    while (windowSum >= s) {\n      minLength = Math.min(minLength, windowEnd - windowStart + 1);\n      windowSum -= arr[windowStart];\n      windowStart++;\n    }\n    console.log(windowSum);\n  }\n  if (minLength === Infinity) {\n    return 0;\n  }\n  return minLength;\n};\n\n//while loop would only run once so O(N+N)= O(N)\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- sliding window\n","n":0.068}}},{"i":96,"$":{"0":{"v":"remove-element","n":1},"1":{"v":"\n## Question\n\nGiven an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n\n#### input:\n\nInput: nums = [3,2,2,3], val = 3\n\n#### Output:\n\nOutput: 2, nums = [2,2,_,_]\n\n## Solution\n\nWe can simply use two pointers again for this solution, we will have our first pointer iterate over the array, and have our second pointer point to elements which do not equal to our value. Then as we iterate through the array we move our values found in the array to the back of the array by swapping values in place.\n\n#### Javascript\n\n```javascript\nvar removeElement = function (nums, val) {\n  let p2 = 0; // index of the next element which is not 'key'\n  let p1 = 0;\n  while (p1 < nums.length) {\n    if (nums[p1] !== val) {\n      nums[p2] = nums[p1];\n      p2 += 1;\n    }\n    p1++;\n  }\n  return p2;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Two Pointer\n","n":0.081}}},{"i":97,"$":{"0":{"v":"remove-duplicate","n":1},"1":{"v":"\n## Question\n\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\n#### input:\n\nInput: nums = [1,1,2]\n\n#### Output:\n\nOutput: 2, nums = [1,2,_]\n\n## Solution\n\nWe can use our two pointer pattern to find a solution here, We will first initialize our two pointers to the second element of the array.\nThen we can do a simple while loop to iterate over the array, and as we go through the array we check if our current element is not a duplicate. If it is not a duplicate we make our the value that our second pointer is at equal to the element that our first pointer is at. This way we move elements that are not duplicate in the first half of the array. If we find that the element is a duplicate we simply keep incrementing our first pointer until we find a unique element to swap values.\n\n#### Javascript\n\n```javascript\nconst remove_duplicates = function (arr) {\n  let p1 = 1;\n  let p2 = 1;\n  let count = 1;\n  while (p1 < arr.length) {\n    if (arr[p1] !== arr[p2 - 1]) {\n      arr[p2] = arr[p1];\n      count++;\n      p2++;\n    }\n    p1++;\n  }\n\n  return count;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Two Pointers\n","n":0.069}}},{"i":98,"$":{"0":{"v":"maximum-subarray-of-sizeK","n":1},"1":{"v":"\n## Question\n\nGiven an array as input and k number, find the maximum sub of any contiguous subArray of size k.\n\n#### input:\n\nInput: [2, 1, 5, 1, 3, 2], k=3\n\n#### Output:\n\nOutput: 9\n\n## Solution\n\n#### Javascript\n\n```javascript\nconst max_sub_array_of_size_k = function (k, arr) {\n  let maxSum = [];\n  for (let i = 0; i < arr.length - k + 1; i++) {\n    let currentSum = 0;\n    for (let j = i; j < i + k; j++) {\n      currentSum += arr[j];\n    }\n    maxSum.push(currentSum);\n    console.log(maxSum);\n  }\n  return Math.max(...maxSum);\n};\n\nconst slidingWindow = function (k, arr) {\n  let maxSum = [];\n  let windowSum = 0;\n  let WindowStart = k;\n  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n    windowSum += arr[windowEnd];\n    if (windowEnd >= k - 1) {\n      maxSum.push(windowSum);\n      currentSum -= windowStart;\n      windowStart++;\n    }\n    console.log(maxSum);\n  }\n  return Math.max(...maxSum);\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- sliding window\n","n":0.086}}},{"i":99,"$":{"0":{"v":"longest-substring-with-k-distinct-characters","n":1},"1":{"v":"\n## Question\n\nGiven a string, find the length of the longest substring in it with no more than K distinct characters.\n\n#### input:\n\nInput: String=\"araaci\", K=2\n\n#### Output:\n\nOutput: 4\n\"araa\"\n\n## Solution\n\nWe can approach this problem by using our SlidingWindow pattern. We will be using a map to keep track of the unique characters in our string and increment our char each time we come to a new character. As we do this we want to check if our length of our object is greater than k. If it is we have to resize our window using our windowStart index until the length of our object is less than k.\n\nAs we do this we are tracking the length our max object, to return.\n\n#### Javascript\n\n```javascript\nconst longest_substring_with_k_distinct = function (str, k) {\n  let windowStart = 0;\n  const mem = {};\n  let result = 0;\n  for (windowEnd = 0; windowEnd < str.length; windowEnd++) {\n    if (!(str[windowEnd] in mem)) {\n      mem[str[windowEnd]] = 0;\n    }\n    mem[str[windowEnd]] += 1;\n    while (Object.keys(mem).length > k) {\n      mem[str[windowStart]] -= 1;\n      if (mem[str[windowStart]] === 0) {\n        delete mem[str[windowStart]];\n      }\n      windowStart++;\n    }\n    result = Math.max(result, windowEnd - windowStart + 1);\n  }\n  return result;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- sliding window\n- Map/Set\n","n":0.072}}},{"i":100,"$":{"0":{"v":"longest-substring-with-distinct-characters","n":1},"1":{"v":"\n## Question\n\nGiven a string s, find the length of the longest substring without repeating characters.\n\n#### input:\n\nInput: String=\"aabccbb\"\n\n#### Output:\n\nOutput: 3\n\n## Solution\n\nAs done in most of the other questions we can solve this using our sliding window and a hashmap to keep track of our characters.\n\n#### Javascript\n\n```javascript\nvar lengthOfLongestSubstring = function (s) {\n  const mem = {};\n  let windowStart = 0;\n  let result = 0;\n  for (let windowEnd = 0; windowEnd < s.length; windowEnd++) {\n    let char = s[windowEnd];\n    if (!(char in mem)) {\n      mem[char] = 0;\n    }\n    mem[char]++;\n\n    while (mem[char] > 1) {\n      let removeChar = s[windowStart];\n      mem[removeChar]--;\n      if (mem[removeChar] === 0) {\n        delete mem[removeChar];\n      }\n      windowStart++;\n    }\n    result = Math.max(result, windowEnd - windowStart + 1);\n  }\n  return result;\n};\n//OR using the index of the characters below:\nvar lengthOfLongestSubstring = function (s) {\n  let windowStart = 0,\n    maxLength = 0,\n    charIndexMap = {};\n  for (let windowEnd = 0; windowEnd < s.length; windowEnd++) {\n    const rightChar = s[windowEnd];\n    if (rightChar in charIndexMap) {\n      windowStart = Math.max(windowStart, charIndexMap[rightChar] + 1);\n    }\n    charIndexMap[rightChar] = windowEnd;\n    maxLength = Math.max(maxLength, windowEnd - windowStart + 1);\n  }\n  return maxLength;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- sliding window\n- Map/Set\n","n":0.073}}},{"i":101,"$":{"0":{"v":"longest-subarray-with-ones","n":1},"1":{"v":"\n## Question\n\nGiven a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\n\n#### input:\n\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n\n#### Output:\n\nOutput: 6\n\n## Solution\n\nHere we can continue to use the sliding window pattern, but this time we don't need to use a set or map, as we only have two values binary bits 1 or 0.\nSo we just need to keep track of the maximum number of 1s in our window in a variable. So following previous patterns we can simply subtract the number of 1s in our window and check if the remaining 0s are greater than k. if so we shrink our sliding window.\nAs we do this we're also keeping track of the maximum number of contiguous subarray.\n\n#### Javascript\n\n```javascript\nconst length_of_longest_substring = function (arr, k) {\n  // TODO: Write your code here\n  let numRepeat = 0;\n  let maxResult = 0;\n  let windowStart = 0;\n\n  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n    let p1 = arr[windowEnd];\n    if (p1 === 1) {\n      numRepeat++;\n    }\n    while (windowEnd - windowStart + 1 - numRepeat > k) {\n      let p2 = arr[windowStart];\n      if (p2 === 1) {\n        numRepeat--;\n      }\n      windowStart++;\n    }\n    maxResult = Math.max(maxResult, windowEnd - windowStart + 1);\n  }\n  return maxResult;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- sliding window\n","n":0.067}}},{"i":102,"$":{"0":{"v":"fruit-into-baskets","n":1},"1":{"v":"\n## Question\n\nYou are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.\nYou only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.\nStarting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\nOnce you reach a tree with fruit that cannot fit in your baskets, you must stop.\nGiven the integer array fruits, return the maximum number of fruits you can pick.\n\n#### input:\n\nInput: fruits = [1,2,3,2,2]\n\n#### Output:\n\nOutput: 4\n\n## Solution\n\nTo solve this we can use our SlidingWindow pattern as done previously, but we will be using a map to keep track of each fruit and how many fruits we currently have. As we go through the fruits we increment the count of fruit if it already exists in our map. But as the problem states we can only have two distinct fruits so we check our object against this each time.\nOnce we have gone over that, we decrement our object using our windowstart until we're below that treshold.\nAs we do this we are keeping the longest length of fruits we have in our basket.\n\n#### Javascript\n\n```javascript\nconst fruits_into_baskets = function (fruits) {\n  const mem = {};\n  let windowStart = 0;\n  let result = 0;\n\n  for (windowEnd = 0; windowEnd < fruits.length; windowEnd++) {\n    fruit = fruits[windowEnd];\n    if (!(fruit in mem)) {\n      mem[fruit] = 0;\n    }\n    mem[fruit]++;\n    while (Object.keys(mem).length > 2) {\n      let removeFruit = fruits[windowStart];\n      mem[removeFruit]--;\n      if (mem[removeFruit] === 0) {\n        delete mem[removeFruit];\n      }\n      windowStart++;\n    }\n    result = Math.max(result, windowEnd - windowStart + 1);\n  }\n  return result;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n## Patterns\n","n":0.056}}},{"i":103,"$":{"0":{"v":"four-sum","n":1},"1":{"v":"\n## Question\n\nGiven an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n0 <= a, b, c, d < n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\n\n#### input:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\n\n#### Output:\n\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n## Solution\n\nFor our solution to this problem, we can base it off of our solution for our three sum problem.\n\n#### Javascript\n\n```javascript\nvar fourSum = function (arr, target) {\n  quadruplets = [];\n  arr.sort((a, b) => a - b);\n  for (let i = 0; i < arr.length - 3; i++) {\n    if (i > 0 && arr[i] === arr[i - 1]) continue;\n    helper(arr, i, i + 1, target, quadruplets);\n  }\n  return quadruplets;\n};\nconst helper = (arr, first, second, target, quadruplets) => {\n  for (let i = second; i < arr.length - 2; i++) {\n    if (i > second + 1 && arr[i] === arr[i - 1]) continue;\n    let p1 = i + 1;\n    let p2 = arr.length - 1;\n    while (p1 < p2) {\n      let currentSum = arr[first] + arr[i] + arr[p1] + arr[p2];\n      if (currentSum === target) {\n        quadruplets.push([arr[first], arr[i], arr[p1], arr[p2]]);\n        while (arr[p1] === arr[p1 - 1]) p1++;\n        while (arr[p2] === arr[p2 + 1]) p2--;\n        p1++;\n        p2--;\n      } else if (currentSum < target) {\n        p1++;\n      } else {\n        p2--;\n      }\n    }\n  }\n  return quadruplets;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n- [[Problems.arrays.three-number-sum]]\n\n## Patterns\n\n- Two Pointer\n","n":0.065}}},{"i":104,"$":{"0":{"v":"compress","n":1},"1":{"v":"\n## Question\n\nGiven a string as an input compress it to each character and the number of times they occur in the string.\n\n#### input:\n\ncompress('ccaaatsss');\n\n#### Output:\n\n'2c3at3s'\n\n## Solution\n\nThis question is really similar to our previous question of uncompressing our string.\n\n#### Javascript\n\n```javascript\nconst compress = (s) => {\n  let result = [];\n  let i = 0;\n  let j = 0;\n\n  while (j <= s.length) {\n    if (s[i] === s[j]) {\n      j += 1;\n    } else {\n      const num = j - i;\n      if (num === 1) {\n        result.push(s[i]);\n      } else {\n        result.push(String(num), s[i]);\n      }\n      i = j;\n    }\n  }\n\n  return result.join(\"\");\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n## Patterns\n","n":0.101}}},{"i":105,"$":{"0":{"v":"average-k-elements","n":1},"1":{"v":"\n## Question\n\nGiven an array and k, calculate the average of all subarrays of k contiguous elements.\n\n#### input:\n\nArray: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5\n\n#### Output:\n\nOutput: [2.2, 2.8, 2.4, 3.6, 2.8]\n\n## Solution\n\ngiven this array we can use simply two loops to iterate over the array and calculate the 5 element subarray and divide the sum by k to get the average.\n\nAnother way to approach this is to use our sliding window pattern to solve this question.\n\n#### Javascript\n\n```javascript\nconst bruteForce = (arr, k) => {\n  const result = [];\n  for (let i = 0; i < arr.length - k + 1; i++) {\n    let currentSum = 0;\n    for (let j = i; j < i + k; j++) {\n      currentSum += arr[j];\n    }\n    result.push(currentSum / 5);\n  }\n  return result;\n};\n\nconst SlideWindow = (arr, k) => {\n  const result = [];\n  let windowSum = 0;\n  let windowStart = 0;\n  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n    windowSum += arr[windowEnd];\n    if (windowEnd >= k - 1) {\n      result.push(windowSum / 5);\n      windowSum -= arr[windowStart];\n      windowStart++;\n    }\n  }\n  return result;\n};\n```\n\n#### Java\n\n```java\n\n```\n\n## Concepts\n\n- [[data-structures.arrays]]\n\n## Patterns\n\n- Sliding Window\n","n":0.074}}}]}
